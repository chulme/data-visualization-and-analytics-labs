<!DOCTYPE html>
<html>

<head>
    <title>Lab 3</title>
</head>

<body>
    <script src='https://d3js.org/d3.v7.js'></script>
    <script src="https://unpkg.com/topojson@3"></script>


    <script>


        class Chart {
            constructor() {
                // Set Dimensions
                Chart.X_SIZE = 1150;
                Chart.Y_SIZE = 750;


                Chart.X_MARGIN = 250;
                Chart.Y_MARGIN = 50;

                Chart.X_MAX = Chart.X_SIZE - Chart.X_MARGIN * 2;
                Chart.Y_MAX = Chart.Y_SIZE - Chart.Y_MARGIN * 2;
                Chart.STROKE_WIDTH = 3.5;
                Chart.STROKE_WIDTH_ON_HOVER = 10
                // Append SVG Object to the Page
                Chart.svg = d3.select("body")
                    .append("svg")
                    .attr('width', Chart.X_SIZE)
                    .attr('height', Chart.Y_SIZE)
                    .append("g")
                    .attr("transform", "translate(" + Chart.X_MARGIN + "," + Chart.Y_MARGIN + ")");



                Chart.svg.append("text")
                    .attr("class", "title")
                    .attr("transform", "translate(" + (Chart.X_MAX) / 2 + "," + -20 + ")")
                    .attr("font-size", "24px")
                    .text("COVID-19 cases over time")
                    .style("text-anchor", "middle");

                // Create extents with opposite extents, so that the first read dataset's extents
                // are used instead.
                var xExtent = [new Date(8640000000000000), new Date(0)];
                var yExtent = [Infinity, 0];

                // X Axis
                var x = d3.scaleTime()
                    .domain([xExtent[0], xExtent[1]])
                    .range([0, Chart.X_MAX]);
                Chart.svg.append("g")
                    .attr("class", "bottom_axis")
                    .call(d3.axisBottom(x))
                    .append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("x", Chart.Y_MAX / 2)
                    .attr("y", -25)
                    .attr("dy", "-5.1em")
                    .attr("text-anchor", "middle")
                    .attr("stroke", "black")
                    .text("Covid Cases");

                // Y Axis
                var y = d3.scaleLinear()
                    .domain([yExtent[0], yExtent[1]])
                    .range([Chart.Y_MAX, 0]);
                Chart.svg.append("g")
                    .attr("class", "left_axis")
                    .call(d3.axisLeft(y))
                    .append("text")
                    .attr("y", Chart.Y_MAX + 40)
                    .attr("x", Chart.X_MAX / 2)
                    .attr("text-anchor", "middle")
                    .attr("stroke", "black")
                    .text("Date");

                var buttonWidth = 75;
                var buttonHeight = 25;
                Chart.button = Chart.svg.append("g")
                    .attr("transform", "translate(0,-40)")
                Chart.button.append("rect")
                    .attr("height", buttonHeight)
                    .attr("width", buttonWidth)
                    .attr("fill", "#e7e7e7")
                    .style("stroke", "black")
                    .style("stroke-width", "1");
                Chart.button.append("text")
                    .text("Back")
                    .attr("dy", "0.2em")
                    .style("text-anchor", "middle")
                    .attr("x", (buttonWidth / 2))
                    .attr("y", (buttonHeight / 2));

                Chart.prevData = []
                Chart.layoutIndex = 0;
            }



            draw_line(data, colorScale, onClickFunction, title) {

                var [x, y] = this.get_axis_scales(data);
                this.update_axis(x, y);
                this.update_lines(data, x, y, colorScale, onClickFunction);
                this.update_legend(data, colorScale, onClickFunction);
                this.update_back_button(data, colorScale, onClickFunction, title);
                this.update_title(title)
            }

            update_title(title) {
                Chart.svg.select(".title")
                    .text(title);
            }

            get_axis_scales(data) {
                //Get extents of data
                var flattened_data = [].concat.apply([], data.map(e => e.values));
                var xExtent = d3.extent(flattened_data, d => new Date(d.date))
                var yExtent = d3.extent(flattened_data, d => parseInt(d.total_cases));


                // X Axis
                var x = d3.scaleTime()
                    .domain([xExtent[0], xExtent[1]])
                    .range([0, Chart.X_MAX]);

                // Y Axis
                var y = d3.scaleLinear()
                    .domain([yExtent[0], yExtent[1]])
                    .range([Chart.Y_MAX, 0]);

                return [x, y];
            }

            update_axis(x, y) {
                Chart.svg.select("g .bottom_axis")
                    .attr("transform", "translate(0," + Chart.Y_MAX + ")")
                    .call(d3.axisBottom(x)
                        .tickFormat(d3.timeFormat("%m-%Y")))
                Chart.svg.select("g .left_axis")
                    .call(d3.axisLeft(y));
            }

            update_lines(data, x, y, colorScale, onClickFunction) {
                var line = Chart.svg.selectAll(".line")
                // Add the line
                line
                    .data(data, d => {
                        return d.key
                    })
                    .join(
                        function (enter) {
                            var line = enter.append("path")
                                .on("click", function (d, i) {
                                    onClickFunction(i.key) //All elements have same location, being the continent.
                                })
                                .on("mouseover", function (m, s) {

                                    var hoveredLine = d3.select(this);
                                    const ORIGINAL_COLOR = hoveredLine.attr("stroke");
                                    const ORIGINAL_STROKE_WIDTH = hoveredLine.attr("stroke-width");
                                    Chart.svg.selectAll(".line")
                                        .attr("stroke", (d) => d.key == s.key ? ORIGINAL_COLOR : "#f1f1f1")
                                        .attr("stroke-width", (d) => d.key == s.key ? Chart.STROKE_WIDTH_ON_HOVER : ORIGINAL_STROKE_WIDTH)
                                    hoveredLine.raise(); //Display on top
                                    Chart.svg.selectAll(".legendText")
                                        .style("fill", (d) => d.key == s.key ? "black" : "#f1f1f1")
                                        .style("font-weight", (d) => d.key == s.key ? "bold" : "normal")

                                    Chart.svg.selectAll(".legendCircle").style("fill", (d) => d.key == s.key ? ORIGINAL_COLOR : "#f1f1f1")



                                    //Highlight scatter plot
                                    d3.selectAll(".scatterPlotPoint")
                                        .style("fill", (d, i, elements) => {
                                            const isSameContinent = d.value.continent == s.key;
                                            const isSameCountry = (d.key == s.key);
                                            // Additionally check if s.key==World, to prevent updating points when hovering over world plot.
                                            return (isSameContinent || isSameCountry || s.key == "World") ? d3.select(elements[i]).style("fill") : "#f1f1f1";
                                        })
                                    //Emphasise on map
                                    d3.selectAll(".country").filter(function (d) {
                                        console.log(d, s.key)
                                        return d.continent == s.key || d.properties.name == s.key
                                    }).transition()
                                        .duration(500)
                                        .style("fill", d => {
                                            console.log(ORIGINAL_COLOR)
                                            return ORIGINAL_COLOR
                                        })
                                })
                                .on("mouseout", function () {
                                    //Reset all line colors
                                    Chart.svg.selectAll(".line")
                                        .attr("stroke-width", Chart.STROKE_WIDTH)
                                        .attr("stroke", (d, i) => colorScale(d.key));
                                    Chart.svg.selectAll(".legendText")
                                        .style("fill", "black")
                                        .style("font-weight", "normal");
                                    Chart.svg.selectAll(".legendCircle").style("fill", (d, i) => colorScale(d.key));


                                    //Reset scatter plot
                                    d3.selectAll(".scatterPlotPoint")
                                        .style("fill", (d, i, elements) => {
                                            return continentColorScale(d.value.continent);
                                        })

                                    //Reset map
                                    d3.selectAll(".country")
                                        .transition()
                                        .duration(500)
                                        .style("fill",
                                            "#f1f1f1")


                                })

                            line

                                //.delay((d, i) => i * 200)
                                .attr("class", "line")
                                .attr("fill", "none")

                                .attr("stroke-width", Chart.STROKE_WIDTH)
                                .attr("d", function (d) {
                                    return d3.line()
                                        .x(d => x(new Date(d.date)))
                                        .y(d => y(0))
                                        (d.values)
                                })
                                .attr("stroke", d => {
                                    return colorScale(d.key)
                                })
                                .transition("lineEnter")
                                .duration(500)
                                .attr("d", function (d) {
                                    return d3.line()
                                        .x(d => x(new Date(d.date)))
                                        .y(d => y(d.total_cases))
                                        (d.values)
                                })


                            return line;
                        },
                        function (update) {
                            return update
                                .attr("d", function (d) {
                                    return d3.line()
                                        .x(d => x(new Date(d.date)))
                                        .y(d => y(d.total_cases))
                                        (d.values)
                                }).attr("stroke", (d, i) => {
                                    var my = d;
                                    return colorScale(d.key)

                                });
                        },
                        function (exit) {
                            return exit
                                .remove()
                        })
            }

            update_legend(data, colorScale, onClickFunction) {
                const SPACE_OF_ELEMENTS = 5;
                const NUMBER_OF_ELEMENTS_PER_COLUMN = 30;
                const SPACE_BETWEEN_ROWS = 20;
                const SPACE_BETWEEN_COLUMNS = 150;
                const CIRCLE_HORZ_OFFSET = 30;
                const TEXT_HORZ_OFFSET = 40;
                const CIRCLE_RADIUS = 6;
                const MAX_LABEL_LENGTH = 15;
                var circleColumnCounter = -1;
                var textColumnCounter = -1;

                var _this = this;
                var legend = Chart.svg
                    .selectAll('g.legend')
                    .data(data, d => d.key)
                    .join(
                        function (enter) {

                            Chart.back_elements = { data: data, colorScale: colorScale, onClickFunction: onClickFunction };

                            var legend_element_container =
                                enter.append("g")
                                    .attr("class", "legend")
                                    .on("mouseover", function (m, s) {

                                        var hoveredCircle = d3.select(this).select("circle");
                                        const ORIGINAL_COLOR = hoveredCircle.style("fill");
                                        const ORIGINAL_STROKE_WIDTH = hoveredCircle.attr("stroke-width");

                                        var lines = Chart.svg.selectAll(".line")
                                            .attr("stroke", (d) => d.key == s.key ? ORIGINAL_COLOR : "#f1f1f1")
                                            .attr("stroke-width", (d) => d.key == s.key ? Chart.STROKE_WIDTH_ON_HOVER : Chart.STROKE_WIDTH)

                                        lines.filter(d => (d.key == s.key)).raise()

                                        Chart.svg.selectAll(".legendText")
                                            .style("fill", (d) => d.key == s.key ? "black" : "#f1f1f1")
                                            .style("font-weight", (d) => d.key == s.key ? "bold" : "normal")

                                        Chart.svg.selectAll(".legendCircle").style("fill", (d) => d.key == s.key ? ORIGINAL_COLOR : "#f1f1f1")

                                        //Highlight scatter plot
                                        d3.selectAll(".scatterPlotPoint")
                                            .style("fill", (d, i, elements) => {
                                                const isSameContinent = d.value.continent == s.key;
                                                const isSameCountry = (d.key == s.key);
                                                // Additionally check if s.key==World, to prevent updating points when hovering over world plot.
                                                return (isSameContinent || isSameCountry || s.key == "World") ? d3.select(elements[i]).style("fill") : "#f1f1f1";
                                            })

                                        //Emphasise on map
                                        d3.selectAll(".country").filter(function (d) {
                                            console.log(d, s.key)
                                            return d.continent == s.key || d.properties.name == s.key
                                        }).transition()
                                            .duration(500)
                                            .style("fill", d => {
                                                console.log(ORIGINAL_COLOR)
                                                return ORIGINAL_COLOR
                                            })





                                    })
                                    .on("mouseout", function () {
                                        //Reset all line colors
                                        Chart.svg.selectAll(".line")
                                            .attr("stroke-width", Chart.STROKE_WIDTH)
                                            .attr("stroke", (d, i) => colorScale(d.key));
                                        Chart.svg.selectAll(".legendText")
                                            .style("fill", "black")
                                            .style("font-weight", "normal");
                                        Chart.svg.selectAll(".legendCircle").style("fill", (d, i) => colorScale(d.key));

                                        //Reset scatter plot
                                        d3.selectAll(".scatterPlotPoint")
                                            .style("fill", (d, i, elements) => {
                                                return continentColorScale(d.value.continent);
                                            })

                                        //Reset map
                                        d3.selectAll(".country")
                                            .transition()
                                            .duration(500)
                                            .style("fill",
                                                "#f1f1f1")

                                    })
                                    .on("click", function (d, i) {
                                        onClickFunction(i.key)
                                    })

                            legend_element_container.append("circle")
                                .attr("class", "legendCircle")
                                .attr("cx", (d, i) => {
                                    circleColumnCounter = ((i) % NUMBER_OF_ELEMENTS_PER_COLUMN == 0) ? circleColumnCounter + 1 : circleColumnCounter;
                                    return Chart.X_MAX + CIRCLE_HORZ_OFFSET + (circleColumnCounter * SPACE_BETWEEN_COLUMNS);
                                })
                                .attr('cy', (d, i) => {
                                    var rotating_index = (i) % NUMBER_OF_ELEMENTS_PER_COLUMN;

                                    return ((rotating_index) * SPACE_BETWEEN_ROWS + (Chart.Y_MAX / 2) - data.length * SPACE_OF_ELEMENTS)
                                })
                                .attr("r", CIRCLE_RADIUS)
                                .style("fill", d => colorScale(d.key))
                            legend_element_container.append("text")
                                .attr("class", "legendText")
                                .attr("x", (d, i) => {
                                    textColumnCounter = ((i) % NUMBER_OF_ELEMENTS_PER_COLUMN == 0) ? textColumnCounter + 1 : textColumnCounter;
                                    return Chart.X_MAX + TEXT_HORZ_OFFSET + (textColumnCounter * SPACE_BETWEEN_COLUMNS);
                                })
                                .attr('y', (d, i) => {
                                    var rotating_index = (i) % NUMBER_OF_ELEMENTS_PER_COLUMN;
                                    return ((rotating_index) * SPACE_BETWEEN_ROWS + CIRCLE_RADIUS + (Chart.Y_MAX / 2) - data.length * SPACE_OF_ELEMENTS)
                                })
                                .attr("text-anchor", "start")
                                .text(d => d.key.length > MAX_LABEL_LENGTH ? d.key.slice(0, MAX_LABEL_LENGTH) + "..." : d.key)
                        },
                        function (update) {
                            update.select("circle")
                                .attr("class", "legendCircle")
                                .attr("cx", (d, i) => {
                                    circleColumnCounter = ((i) % NUMBER_OF_ELEMENTS_PER_COLUMN == 0) ? circleColumnCounter + 1 : circleColumnCounter;
                                    return Chart.X_MAX + CIRCLE_HORZ_OFFSET + (circleColumnCounter * SPACE_BETWEEN_COLUMNS);
                                })
                                .attr('cy', (d, i) => {
                                    var rotating_index = (i) % NUMBER_OF_ELEMENTS_PER_COLUMN;
                                    return ((rotating_index) * SPACE_BETWEEN_ROWS + (Chart.Y_MAX / 2) - data.length * SPACE_OF_ELEMENTS)
                                })
                                .attr("r", CIRCLE_RADIUS)
                                .style("fill", d => colorScale(d.key))
                            update.select("text")
                                .attr("class", "legendText")
                                .attr("x", (d, i) => {
                                    textColumnCounter = ((i) % NUMBER_OF_ELEMENTS_PER_COLUMN == 0) ? textColumnCounter + 1 : textColumnCounter;
                                    return Chart.X_MAX + TEXT_HORZ_OFFSET + (textColumnCounter * SPACE_BETWEEN_COLUMNS);
                                })
                                .attr('y', (d, i) => {
                                    var rotating_index = (i) % NUMBER_OF_ELEMENTS_PER_COLUMN;
                                    return ((rotating_index) * SPACE_BETWEEN_ROWS + CIRCLE_RADIUS + (Chart.Y_MAX / 2) - data.length * SPACE_OF_ELEMENTS)
                                })
                                .attr("text-anchor", "start")
                                .text(d => d.key.length > MAX_LABEL_LENGTH ? d.key.slice(0, MAX_LABEL_LENGTH) + "..." : d.key)
                        },
                        function (exit) {
                            exit.remove()
                        }
                    )

            }

            update_back_button(data, colorScale, onClickFunction, title) {
                Chart.prevData.push({ data: data, colorScale: colorScale, onClickFunction: onClickFunction, title: title });

                if (Chart.layoutIndex == 0) {
                    Chart.button
                        .style("visibility", "hidden");
                } else {
                    Chart.button
                        .style("visibility", "visible");
                }
                var _this = this;
                Chart.button.on("click", function () {
                    Chart.layoutIndex -= 2;
                    var prevData = Chart.prevData[Chart.layoutIndex];
                    _this.draw_line(prevData.data, prevData.colorScale, prevData.onClickFunction, prevData.title)
                });

                Chart.layoutIndex++;

            }
        }

        function displayCovidCasesWorld() {

            var filtered = raw_data.filter(d => d.iso_code == "OWID_WRL");
            var continentData = new Map()
            continentData.set("World", filtered)
            var finalData = Array.from(continentData, function (item) {
                return { key: item[0], values: item[1] }
            });
            var colorScale = d3.scaleOrdinal().domain([finalData]).range(d3.schemeSet3);

            covidCasesGraph.draw_line(finalData, colorScale, displayCovidCasesPerContinent, "COVID-19 cases over time");

        }

        function displayCovidCasesPerContinent() {

            const ISO_CODES = ["OWID_ASI", "OWID_AFR", "OWID_EUR", "OWID_NAM", "OWID_SAM", "OWID_OCE"];
            const continents = ["Asia", "Africa", "Europe", "North America", "South America", "Oceania"];


            var filtered = raw_data.filter(d => ISO_CODES.includes(d.iso_code));

            var continentCovidDataMap = d3.group(filtered, d => d.iso_code)

            var continentData = new Map()
            for (let i = 0; i < ISO_CODES.length; i++) {
                continentData.set(continents[i], continentCovidDataMap.get(ISO_CODES[i]))
            }

            var finalData = Array.from(continentData, function (item) {
                return { key: item[0], values: item[1] }
            });

            finalData.sort((x, y) => d3.ascending(x.key, y.key));


            covidCasesGraph.draw_line(finalData, continentColorScale, displayCovidCasesPerCountry, "COVID-19 cases over time, per continent");

        }

        function displayCovidCasesPerCountry(continent) {

            var filtered = raw_data.filter(d => d.continent == continent);
            var countryCovidDataMap = d3.group(filtered, d => d.location)
            var colorScale = d3.scaleOrdinal().domain([countryCovidDataMap.keys()]).range(d3.schemeSet3);

            var countryData = new Map()
            countryCovidDataMap.forEach(function (val, key) {
                countryData.set(key, val)
            })
            var finalData = Array.from(countryData, function (item) {
                return { key: item[0], values: item[1] }
            });
            covidCasesGraph.draw_line(finalData, colorScale, displayVaccinesGraph, "COVID-19 cases over time in " + continent)

        }

        function displayVaccinesGraph(continent) {
            console.log("Displaying vaccine graph")
        }
        function displayWeathVsCasesScatterPlot() {

            // Process data to get data grouped per country, while removing non-country rows
            var maxDate = new Date(d3.max(raw_data, d => new Date(d.date)))
            var filtered = raw_data
                .filter(d => new Date(d.date).getTime() === maxDate.getTime())
                .filter(d => !d.iso_code.includes("OWID"))
                .filter(d => d.gdp_per_capita > 0)//50,000,000

            // .filter(d => d.gdp_per_capita < 100000)//50,000,000
            // .filter(d => d.total_cases < 50000000)//50,000,000

            var countryCovidDataMap = d3.group(filtered, d => d.location)

            var continents = Array.from(d3.group(filtered, d => d.continent).keys()).sort((x, y) => d3.ascending(x, y))

            var countryData = new Map()
            countryCovidDataMap.forEach(function (val, key) {
                countryData.set(key, val[0])
            })
            var data = Array.from(countryData, function (item) {
                return { key: item[0], value: item[1] }
            });


            // Initialise graph 

            // Set Dimensions
            X_SIZE = 2350;
            Y_SIZE = 600;
            X_MARGIN =250;
            Y_MARGIN = 100;

            X_MAX = X_SIZE - X_MARGIN * 2;
            Y_MAX = Y_SIZE - Y_MARGIN * 2;
            STROKE_WIDTH = 3.5;
            STROKE_WIDTH_ON_HOVER = 6.5

            // Append SVG Object to the Page
            var svg = d3.select("body")
                .append("svg")
                .attr('width', X_SIZE)
                .attr('height', Y_SIZE)
                .append("g")
                .attr("transform", "translate(" + (X_MARGIN+50) + "," + Y_MARGIN + ")");

            svg.append("text")
                .attr("transform", "translate(" + (X_MAX) / 2 + "," + -20 + ")")
                .attr("font-size", "24px")
                .text("Relation between the relative 'wealth' of a population and the evolution of the pandemic.")
                .style("text-anchor", "middle");

            // Create extents
            var flattened_data = [].concat.apply([], data.map(e => e.value));
            var xExtent = d3.extent(flattened_data, d => parseInt(d.gdp_per_capita))
            var yExtent = d3.extent(flattened_data, d => parseInt(d.total_cases));

            const numberOfVerticalTicks = 6;
            const numberOfHorizontalTicks = 7;

            // X Axis
            var x = d3.scaleLog()
                .base(2)
                .domain([xExtent[0], xExtent[1]])
                .range([0, X_MAX]);

            //Bottom  
            svg.append("g")
                .attr("class", "bottom_axis")
                .call(d3.axisBottom(x).ticks(numberOfVerticalTicks))
                .attr("transform", "translate(0, " + Y_MAX + ")")
                .append("text")
                .attr("x", X_MAX / 2)
                .attr("y", 40)
                .attr("text-anchor", "middle")
                .attr("stroke", "black")
                .text("GDP per capita");

            // Y Axis
            var y = d3.scaleLog()
                .domain([yExtent[0], yExtent[1]])
                .range([Y_MAX, 0])
                .base(10)

            svg.append("g")
                .attr("class", "left_axis")
                .call(d3.axisLeft(y).ticks(numberOfHorizontalTicks))
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -(Y_MAX / 2))
                .attr("y", -25)
                .attr("dy", "-5.1em")
                .attr("text-anchor", "middle")
                .attr("stroke", "black")
                .text("Covid Cases");

            //Gridlines
            svg.selectAll("horizontalGridline").data(y.ticks(numberOfHorizontalTicks)).enter()
                .append("line")
                .attr("x1", 0)
                .attr("x2", X_MAX)
                .attr("y1", d => y(d))
                .attr("y2", d => y(d))
                .attr("stroke", "#d3d3d3")
                .attr("stroke-width", "0.5px");

            svg.selectAll("verticalGridline").data(x.ticks(numberOfVerticalTicks)).enter()
                .append("line")
                .attr("x1", d => x(d))
                .attr("x2", d => x(d))
                .attr("y1", 0)
                .attr("y2", Y_MAX)

                .attr("stroke", "#d3d3d3")
                .attr("stroke-width", "0.5px");

            // Add Info Box
            const detailBoxHorzOffset = 10;
            const detailBoxHeight = 75;
            const detailBoxWidth = 200;
            const spaceBetweenTextRows = 20;

            var button = svg.append("g")
                .attr("transform", "translate(" + X_MAX + "," + 5 + ")")
            button.append("rect")
                .attr("height", detailBoxHeight)
                .attr("width", detailBoxWidth)
                .attr("fill", "#e7e7e7")
                .style("stroke", "black")
                .style("stroke-width", "1");
            button.append("text")
                .text("Click on a datapoint")
                .attr("dy", "0.2em")
                .style("text-anchor", "middle")
                .attr("x", (detailBoxWidth / 2))
                .attr("y", (detailBoxHeight / 2) - spaceBetweenTextRows);
            button.append("text")
                .text("for more information.")
                .attr("dy", "0.2em")
                .style("text-anchor", "middle")
                .attr("x", (detailBoxWidth / 2))
                .attr("y", (detailBoxHeight / 2) + spaceBetweenTextRows);

            // Add dots
            const dotRadius = 3.5;
            const selectedDotRadius = 5;
            var scatterPlotPoints = svg.append('g')
                .selectAll("dot")
                .data(data, d => d.key)
                .join("circle")
                .attr("class", "scatterPlotPoint")
                .attr("cx", (d) => x(d.value.gdp_per_capita))
                .attr("cy", (d) => y(d.value.total_cases))
                .attr("r", 3.5)
                .style("fill", (d, i) => continentColorScale(d.value.continent))
                .on("mouseover", function (m, s) {

                    //Emphasise hovered element
                    var hoveredCircle = d3.select(this);
                    const ORIGINAL_COLOR = hoveredCircle.style("fill");
                    svg.selectAll(".scatterPlotPoint")
                        .style("fill", (d) => d.key == s.key ? ORIGINAL_COLOR : "#f1f1f1")
                        .attr("r", (d) => d.key == s.key ? selectedDotRadius : dotRadius)
                    hoveredCircle.raise(); //Display on top

                    //Emphasise on legend
                    svg.selectAll(".legendText")
                        .style("fill", (d) => {
                            return d == s.value.continent ? "black" : "#f1f1f1"
                        })
                        .style("font-weight", (d) => d == s.value.continent ? "bold" : "normal")
                    svg.selectAll(".legendCircle").style("fill", (d) => d == s.value.continent ? ORIGINAL_COLOR : "#f1f1f1")

                    //Update info box
                    button.selectAll("text").remove()
                    button.append("text")
                        .text(s.value.location)
                        .attr("dy", "0.2em")
                        .style("text-anchor", "middle")
                        .style("font-weight", "bold")
                        .attr("x", (detailBoxWidth / 2))
                        .attr("y", (detailBoxHeight / 2) - spaceBetweenTextRows);

                    button.append("text")
                        .text("GDP per capita: " + s.value.gdp_per_capita)
                        .attr("dy", "0.2em")
                        .style("text-anchor", "middle")
                        .attr("x", (detailBoxWidth / 2))
                        .attr("y", (detailBoxHeight / 2));
                    button.append("text")
                        .text("Covid Cases: " + s.value.total_cases)
                        .attr("dy", "0.2em")
                        .style("text-anchor", "middle")
                        .attr("x", (detailBoxWidth / 2))
                        .attr("y", (detailBoxHeight / 2) + spaceBetweenTextRows);

                    //Emphasise on line graph
                    var lines = d3.selectAll(".line")
                        .attr("stroke", (d, i, elements) => {
                            const isSameContinent = d.key == s.value.continent;
                            const isSameCountry = d.key == s.key;
                            d.originalColor = d3.select(elements[i]).attr("stroke");
                            return (isSameContinent || isSameCountry || d.key == "World") ? d.originalColor : "#f1f1f1"
                        })
                })
                .on("mouseout", function (m, s) {
                    //Reset all scatter points
                    svg.selectAll(".scatterPlotPoint")
                        .attr("r", dotRadius)
                        .style("fill", (d, i) => {
                            return continentColorScale(d.value.continent)
                        });
                    //Reset legend
                    svg.selectAll(".legendText")
                        .style("fill", "black")
                        .style("font-weight", "normal");
                    svg.selectAll(".legendCircle").style("fill", (d, i) => continentColorScale(d));

                    //Reset  line graph
                    var lines = d3.selectAll(".line")
                        .attr("stroke", (d) => {
                            return d.originalColor
                        })
                    // .attr("stroke-width", (d, i, elements) => {
                    //     return (isSameContinent || isSameContinent) ? Chart.STROKE_WIDTH_ON_HOVER : d3.select(elements[i]).attr("stroke-width");
                    // })

                });

            var brush = d3.brush()
                .on("brush", highlightBrushedCircles)
                .on("end", resetBrush)
            svg.append("g").call(brush)

            function highlightBrushedCircles(event) {

                //Reset colours on scatter plot and map
                scatterPlotPoints
                    .style("fill", "#f1f1f1")
                d3.selectAll(".country")
                    .style("fill", "#f1f1f1")

                if (event.selection != null) {
                    var brushCoords = d3.brushSelection(this)
                    var selectedPoints = scatterPlotPoints.filter(function () {
                        const cx = d3.select(this).attr("cx");
                        const cy = d3.select(this).attr("cy");


                        const x0 = brushCoords[0][0];
                        const x1 = brushCoords[1][0];
                        const y0 = brushCoords[0][1];
                        const y1 = brushCoords[1][1];
                        return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1;
                    })
                        .style("fill", function (d, i) {
                            return continentColorScale(d.value.continent)
                        })
                    //console.log(selectedPoints.data()) //2d array

                    var linkedCountries = d3.selectAll(".country").filter(function (a) {
                        return selectedPoints.data().find(point => point.key == a.properties.name)
                        //console.log(a.properties.name)
                    })

                    var selectedCountries = selectedPoints.data().map(d => {
                        return d.key
                    })

                    selectedCountriesColorScale = d3.scaleOrdinal().domain(selectedCountries).range(d3.schemeSet3);

                    linkedCountries.style("fill", d => {
                        return selectedCountriesColorScale(d.properties.name)
                    })

                    var filtered = raw_data.filter(d => selectedCountries.includes(d.location));

                    var continentCovidDataMap = d3.group(filtered, d => d.location)

                    var finalData = Array.from(continentCovidDataMap, function (item) {
                        return { key: item[0], values: item[1] }
                    });


                    covidCasesGraph.draw_line(finalData, selectedCountriesColorScale, null, "Covid for selection")
                }
            }

            function resetBrush({ selection }) {
                if (selection) { return; }
                console.log("Resetting")
                displayCovidCasesWorld()
                //Reset scatter plot points
                scatterPlotPoints
                    .transition()
                    .duration(500)

                    .style("fill", d => {
                        console.log(d)
                        return continentColorScale(d.value.continent)
                    })
                //Reset map
                d3.selectAll(".country")
                    .transition()
                    .duration(500)
                    .style("fill", "#f1f1f1")


            }



            //Legend
            const SPACE_OF_ELEMENTS = 5;
            const NUMBER_OF_ELEMENTS_PER_COLUMN = 30;
            const SPACE_BETWEEN_ROWS = 20;
            const SPACE_BETWEEN_COLUMNS = 150;
            const CIRCLE_HORZ_OFFSET = 30;
            const TEXT_HORZ_OFFSET = 40;
            const CIRCLE_RADIUS = 6;
            const MAX_LABEL_LENGTH = 15;
            var circleColumnCounter = -1;
            var textColumnCounter = -1;
            var legend = svg
                .selectAll('g.legendScatter')
                .data(continents)
                .join(
                    function (enter) {

                        var legend_element_container =
                            enter.append("g")
                                .attr("class", "legendScatter")
                                .on("mouseover", function (m, s) {

                                    var hoveredCircle = d3.select(this).select("circle");
                                    const ORIGINAL_COLOR = hoveredCircle.style("fill");
                                    var points = svg.selectAll(".scatterPlotPoint")
                                        .style("fill", (d) => {
                                            return d.value.continent == s ? ORIGINAL_COLOR : "#f1f1f1"
                                        })

                                    points.filter(d => (d.value.continent == s)).raise()

                                    svg.selectAll(".legendText")
                                        .style("fill", (d) => d == s ? "black" : "#f1f1f1")
                                        .style("font-weight", (d) => d == s ? "bold" : "normal")
                                    svg.selectAll(".legendCircle").style("fill", (d) => {
                                        return d == s ? ORIGINAL_COLOR : "#f1f1f1"
                                    })
                                    //Emphasise on line graph
                                    var lines = d3.selectAll(".line")
                                        .attr("stroke", (d, i, elements) => {
                                            const isSameContinent = d.key == s;
                                            const isSameCountry = d.values[0].continent == s;
                                            d.originalColor = d3.select(elements[i]).attr("stroke");
                                            return (isSameContinent || isSameCountry || d.key == "World") ? d.originalColor : "#f1f1f1"
                                        })

                                    //Emphasise on map
                                    d3.selectAll(".country").filter(function (d) {
                                        return d.continent == s
                                    }).transition()
                                        .duration(500)
                                        .style("fill", d => continentColorScale(d.continent))
                                })
                                .on("mouseout", function () {
                                    //Reset scatter plot
                                    svg.selectAll(".scatterPlotPoint")
                                        .style("fill", (d, i) => continentColorScale(d.value.continent));
                                    svg.selectAll(".legendText")
                                        .style("fill", "black")
                                        .style("font-weight", "normal");
                                    svg.selectAll(".legendCircle").style("fill", (d, i) => {
                                        return continentColorScale(d);
                                    })

                                    //Reset line graph
                                    var lines = d3.selectAll(".line")
                                        .attr("stroke", (d, i, elements) => {
                                            return d.originalColor;
                                        })
                                    //Reset map
                                    d3.selectAll(".country")
                                        .transition()
                                        .duration(500)
                                        .style("fill",
                                            "#f1f1f1")


                                })

                        legend_element_container.append("circle")
                            .attr("class", "legendCircle")
                            .attr("cx", (d, i) => {
                                return X_MAX + CIRCLE_HORZ_OFFSET;
                            })
                            .attr('cy', (d, i) => {
                                return (i * SPACE_BETWEEN_ROWS + (Y_MAX / 2) - continents.length * SPACE_OF_ELEMENTS)
                            })
                            .attr("r", CIRCLE_RADIUS)
                            .style("fill", d =>
                                continentColorScale(d)
                            )
                        legend_element_container.append("text")
                            .attr("class", "legendText")
                            .attr("x", (d, i) => {
                                return X_MAX + TEXT_HORZ_OFFSET;
                            })
                            .attr('y', (d, i) => {
                                return (i * SPACE_BETWEEN_ROWS + CIRCLE_RADIUS + (Y_MAX / 2) - continents.length * SPACE_OF_ELEMENTS)
                            })
                            .attr("text-anchor", "start")
                            .text((d, i) => {
                                return d;
                            })
                    },
                    function (exit) {
                        exit.remove()
                    }
                )


        }

        function displayCovidMap() {
            // Set Dimensions
            X_SIZE = 1150;
            Y_SIZE = 750;
            X_MARGIN = 50;
            Y_MARGIN = 50;

            X_MAX = X_SIZE - X_MARGIN * 2;
            Y_MAX = Y_SIZE - Y_MARGIN * 2;
            STROKE_WIDTH = 3.5;
            STROKE_WIDTH_ON_HOVER = 6.5

            // Append SVG Object to the Page
            var svg = d3.select("body")
                .append("svg")
                .attr('width', X_SIZE)
                .attr('height', Y_SIZE)
                .append("g")
                .attr("transform", "translate(" + X_MARGIN + "," + Y_MARGIN + ")");

            svg.append("text")
                .attr("transform", "translate(" + (X_MAX) / 2 + "," + -20 + ")")
                .attr("font-size", "24px")
                .text("Covid Evolution Map.")
                .style("text-anchor", "middle");

            //Load map data
            d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson").then(mapData => {


                //Rename to align with OWID dataset.
                mapData.features.forEach(element => {
                    switch (element.properties.name) {
                        case "USA":
                            element.properties.name = "United States"
                            break;
                        case "England":
                            element.properties.name = "United Kingdom"
                            break;
                        case "Republic of the Congo":
                            element.properties.name = "Democratic Republic of Congo"
                            break;
                        default:
                            break;
                    }
                });

                var maxDate = new Date(d3.max(raw_data, d => new Date(d.date)))


                var filtered = raw_data.filter(d => !d.iso_code.includes("OWID"))
                    .filter(d => new Date(d.date).getTime() === maxDate.getTime());
                var countryCovidDataMap = d3.group(filtered, d => d.location)


                var countryData = new Map()
                countryCovidDataMap.forEach(function (val, key) {
                    countryData.set(key, val)

                    //Returns -1 if country not found in mapData
                    var indexOfMapDataContainingCountry = mapData.features.map(function (e) {
                        return e.properties.name
                    }).indexOf(key)

                    if (indexOfMapDataContainingCountry > 0) {
                        mapData.features[indexOfMapDataContainingCountry].continent = val[0].continent;
                    } else {
                        console.log("No country found for ", key, indexOfMapDataContainingCountry)
                    }
                })


                //Create map
                const projection = d3.geoMercator()
                    .scale(160)
                    .center([150, 70])
                    .translate([X_MAX / 2, Y_MAX / 2]);
                const path = d3.geoPath(projection);

                var paths = svg.selectAll("path")
                    .data(mapData.features)
                    .enter()
                    .append("path")
                    .attr("class", "country")
                    .attr("id", d => {
                        return d.continent != undefined ? d.continent.split(" ").join("") : "UnknownContinent"

                    })
                    .attr("d", (d) => path(d))
                    .attr("fill", "#f1f1f1")
                    .style("stroke", "black")
                    .style("stroke-width", 0);
                paths.on("mouseover", function (m, s) {

                    const isAnyContinentSelected = paths.filter(path => {
                        return path.clicked == true
                    }).size() > 0 ? true : false;

                    if (s.continent != undefined && !isAnyContinentSelected) {
                        d3.selectAll("#" + s.continent.split(" ").join(""))
                            .transition("continentHover")
                            .duration(200)
                            .style("fill", d => continentColorScale(s.continent))



                        //Display breakdown per continent, with emphasis on the selected continent
                        displayCovidCasesPerContinent()

                        var line = d3.selectAll(".line").filter(function (line) {
                            return line.key == s.continent
                        })
                            .transition("pulseEnter")
                            .attr("stroke-width", Chart.STROKE_WIDTH_ON_HOVER)

                        //Highlight continent on scatter plot
                        d3.selectAll(".scatterPlotPoint").filter(function (point) {
                            return point.value.continent
                        })

                        //Highlight scatter plot
                        d3.selectAll(".scatterPlotPoint")
                            .style("fill", (d, i, elements) => {
                                const isSameContinent = d.value.continent == s.continent;
                                // Additionally check if s.key==World, to prevent updating points when hovering over world plot.
                                return (isSameContinent) ? d3.select(elements[i]).style("fill") : "#f1f1f1";
                            })
                    }
                })
                    .on("mouseout", function (m, s) {
                        const isAnyContinentSelected = paths.filter(path => {
                            return path.clicked == true
                        }).size() > 0 ? true : false;

                        console.log("isAnyContinentSelected", isAnyContinentSelected)
                        if (!isAnyContinentSelected) {
                            d3.selectAll(".country")
                                .transition("pulseExit")
                                .duration(200)
                                .style("fill", "#f1f1f1")
                                .style("stroke-width", 0)

                            d3.selectAll(".line")
                                .attr("stroke-width", Chart.STROKE_WIDTH)

                            //Reset scatter plot
                            d3.selectAll(".scatterPlotPoint")
                                .style("fill", (d, i, elements) => {
                                    return continentColorScale(d.value.continent);
                                })

                            displayCovidCasesWorld()
                        }
                    })
                    .on("click", function (m, s) {

                        if (s.continent != undefined) {

                            // Deselect all paths
                            paths.each(function (path) {
                                if (path.continent != s.continent) {

                                    if (path.clicked == true) {
                                        path.clicked = false;

                                    }
                                    d3.select(this)
                                        .transition("hm")
                                        .duration(300)
                                        .style("stroke-width", 0)
                                        .style("fill", "#f1f1f1")

                                }

                            });

                            s.clicked = (s.clicked == undefined) ? true : !s.clicked;
                            if (s.clicked == true) {


                                d3.selectAll("#" + s.continent.split(" ").join(""))
                                    .transition("continentClick")
                                    .duration(200)
                                    .style("stroke-width", "1")
                                    .style("fill", continentColorScale(s.continent))


                                //Display breakdown per continent, with emphasis on the selected continent
                                displayCovidCasesPerCountry(s.continent)

                                var line = d3.selectAll(".line").filter(function (line) {
                                    return line.key == s.continent
                                })
                                    .transition("pulseEnter")
                                    .attr("stroke-width", Chart.STROKE_WIDTH_ON_HOVER)

                                //Highlight continent on scatter plot
                                d3.selectAll(".scatterPlotPoint").filter(function (point) {
                                    return point.value.continent
                                })

                                //Highlight scatter plot
                                d3.selectAll(".scatterPlotPoint")
                                    .style("fill", (d, i, elements) => {
                                        const isSameContinent = d.value.continent == s.continent;
                                        // Additionally check if s.key==World, to prevent updating points when hovering over world plot.
                                        return (isSameContinent) ? d3.select(elements[i]).style("fill") : "#f1f1f1";
                                    })
                            } else {
                                d3.selectAll("#" + s.continent.split(" ").join(""))
                                    .transition("continentClickHide")
                                    .duration(200)
                                    .style("stroke-width", "0")
                                displayCovidCasesPerContinent()

                            }
                        }

                    });

                //Create country centroids
                var countryCentroids = new Map(mapData.features.map(d => {
                    const centroid = path.centroid(d.geometry);
                    return [d.properties.name, { x: centroid[0], y: centroid[1] }]
                }))


                countryData.forEach((data, key) => {
                    if (countryCentroids.has(key)) {
                        data.centroid = countryCentroids.get(key)
                    } else {
                        countryData.delete(key)
                    }
                })

                var extents = d3.extent(countryData, d => {
                    return parseInt(d[1][0].total_cases);
                })
                var radiusScale = d3.scaleSqrt()
                    .domain(extents)
                    .range([0, 30]);

                svg.append("g")
                    .selectAll("circle")
                    .data(countryData)
                    .enter()
                    .append("circle")
                    .attr("fill", d => {
                        return continentColorScale(d[1][0].continent)
                    })
                    .attr("stroke", "black")
                    .style("opacity", 0.4)
                    .attr("cx", d => {
                        return d[1].centroid.x
                    })
                    .attr("cy", d => {
                        return d[1].centroid.y
                    })
                    .attr("r", d => {
                        var radius = radiusScale(d[1][0].total_cases);
                        return radius
                    })

            })

        }


        d3.csv('https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv')
            .then(function (data) {
                window.raw_data = data; //global data;
                const continents = ["Asia", "Africa", "Europe", "North America", "South America", "Oceania"];
                window.continentColorScale = d3.scaleOrdinal().domain([data]).range(d3.schemeSet3);

            })
            .then(function () {

                displayCovidMap()
                window.covidCasesGraph = new Chart();
                displayCovidCasesWorld()
                displayWeathVsCasesScatterPlot()
            })
    </script>
</body>

</html>