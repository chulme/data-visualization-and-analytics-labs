<!DOCTYPE html>
<html>

<head>
    <title>Lab 3</title>
</head>

<body>
    <script src='https://d3js.org/d3.v7.min.js'></script>
    <script>
        var continentColorScale;

        class Chart {
            constructor() {
                // Set Dimensions
                Chart.X_SIZE = 1550;
                Chart.Y_SIZE = 750;
                Chart.X_MARGIN = 350;
                Chart.Y_MARGIN = 50;

                Chart.X_MAX = Chart.X_SIZE - Chart.X_MARGIN * 2;
                Chart.Y_MAX = Chart.Y_SIZE - Chart.Y_MARGIN * 2;
                Chart.STROKE_WIDTH = 3.5;
                Chart.STROKE_WIDTH_ON_HOVER = 6.5
                // Append SVG Object to the Page
                Chart.svg = d3.select("body")
                    .append("svg")
                    .attr('width', Chart.X_SIZE)
                    .attr('height', Chart.Y_SIZE)
                    .append("g")
                    .attr("transform", "translate(" + Chart.X_MARGIN + "," + Chart.Y_MARGIN + ")");



                Chart.svg.append("text")
                    .attr("class", "title")
                    .attr("transform", "translate(" + (Chart.X_MAX) / 2 + "," + -20 + ")")
                    .attr("font-size", "24px")
                    .text("COVID-19 cases over time")
                    .style("text-anchor", "middle");

                // Create extents with opposite extents, so that the first read dataset's extents
                // are used instead.
                var xExtent = [new Date(8640000000000000), new Date(0)];
                var yExtent = [Infinity, 0];

                // X Axis
                var x = d3.scaleTime()
                    .domain([xExtent[0], xExtent[1]])
                    .range([0, Chart.X_MAX]);
                Chart.svg.append("g")
                    .attr("class", "bottom_axis")
                    .call(d3.axisBottom(x))
                    .append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("x", Chart.Y_MAX / 2)
                    .attr("y", -25)
                    .attr("dy", "-5.1em")
                    .attr("text-anchor", "middle")
                    .attr("stroke", "black")
                    .text("Covid Cases");

                // Y Axis
                var y = d3.scaleLinear()
                    .domain([yExtent[0], yExtent[1]])
                    .range([Chart.Y_MAX, 0]);
                Chart.svg.append("g")
                    .attr("class", "left_axis")
                    .call(d3.axisLeft(y))
                    .append("text")
                    .attr("y", Chart.Y_MAX + 40)
                    .attr("x", Chart.X_MAX / 2)
                    .attr("text-anchor", "middle")
                    .attr("stroke", "black")
                    .text("Date");

                var buttonWidth = 75;
                var buttonHeight = 25;
                Chart.button = Chart.svg.append("g")
                    .attr("transform", "translate(0,-40)")
                Chart.button.append("rect")
                    .attr("height", buttonHeight)
                    .attr("width", buttonWidth)
                    .attr("fill", "#e7e7e7")
                    .style("stroke", "black")
                    .style("stroke-width", "1");
                Chart.button.append("text")
                    .text("Back")
                    .attr("dy", "0.2em")
                    .style("text-anchor", "middle")
                    .attr("x", (buttonWidth / 2))
                    .attr("y", (buttonHeight / 2));

                Chart.prevData = []
                Chart.layoutIndex = 0;
            }



            draw_line(data, colorScale, onClickFunction, title) {

                var [x, y] = this.get_axis_scales(data);
                this.update_axis(x, y);
                this.update_lines(data, x, y, colorScale, onClickFunction);
                this.update_legend(data, colorScale, onClickFunction);
                this.update_back_button(data, colorScale, onClickFunction, title);
                this.update_title(title)
            }

            update_title(title) {
                Chart.svg.select(".title")
                    .text(title);
            }

            get_axis_scales(data) {
                //Get extents of data
                var flattened_data = [].concat.apply([], data.map(e => e.values));
                var xExtent = d3.extent(flattened_data, d => new Date(d.date))
                var yExtent = d3.extent(flattened_data, d => parseInt(d.total_cases));


                // X Axis
                var x = d3.scaleTime()
                    .domain([xExtent[0], xExtent[1]])
                    .range([0, Chart.X_MAX]);

                // Y Axis
                var y = d3.scaleLinear()
                    .domain([yExtent[0], yExtent[1]])
                    .range([Chart.Y_MAX, 0]);

                return [x, y];
            }

            update_axis(x, y) {
                Chart.svg.select("g .bottom_axis")
                    .attr("transform", "translate(0," + Chart.Y_MAX + ")")
                    .call(d3.axisBottom(x)
                        .tickFormat(d3.timeFormat("%m-%Y")))
                Chart.svg.select("g .left_axis")
                    .call(d3.axisLeft(y));
            }

            update_lines(data, x, y, colorScale, onClickFunction) {
                var line = Chart.svg.selectAll(".line")
                // Add the line
                line
                    .data(data, d => d.key)
                    .join(
                        function (enter) {
                            var line = enter.append("path")
                                .on("click", function (d, i) {
                                    onClickFunction(i.key) //All elements have same location, being the continent.
                                })
                                .on("mouseover", function (m, s) {

                                    var hoveredLine = d3.select(this);
                                    const ORIGINAL_COLOR = hoveredLine.attr("stroke");
                                    const ORIGINAL_STROKE_WIDTH = hoveredLine.attr("stroke-width");
                                    Chart.svg.selectAll(".line")
                                        .attr("stroke", (d) => d.key == s.key ? ORIGINAL_COLOR : "#f1f1f1")
                                        .attr("stroke-width", (d) => d.key == s.key ? Chart.STROKE_WIDTH_ON_HOVER : ORIGINAL_STROKE_WIDTH)
                                    hoveredLine.raise(); //Display on top
                                    Chart.svg.selectAll(".legendText")
                                        .style("fill", (d) => d.key == s.key ? "black" : "#f1f1f1")
                                        .style("font-weight", (d) => d.key == s.key ? "bold" : "normal")

                                    Chart.svg.selectAll(".legendCircle").style("fill", (d) => d.key == s.key ? ORIGINAL_COLOR : "#f1f1f1")



                                    //Highlight scatter plot
                                    d3.selectAll(".scatterPlotPoint")
                                        .style("fill", (d, i, elements) => {
                                            const isSameContinent = d.value.continent == s.key;
                                            const isSameCountry = (d.key == s.key);
                                            // Additionally check if s.key==World, to prevent updating points when hovering over world plot.
                                            return (isSameContinent || isSameCountry || s.key == "World") ? d3.select(elements[i]).style("fill") : "#f1f1f1";
                                        })



                                })
                                .on("mouseout", function () {
                                    //Reset all line colors
                                    Chart.svg.selectAll(".line")
                                        .attr("stroke-width", Chart.STROKE_WIDTH)
                                        .attr("stroke", (d, i) => colorScale(d.key));
                                    Chart.svg.selectAll(".legendText")
                                        .style("fill", "black")
                                        .style("font-weight", "normal");
                                    Chart.svg.selectAll(".legendCircle").style("fill", (d, i) => colorScale(d.key));


                                    //Reset scatter plot
                                    d3.selectAll(".scatterPlotPoint")
                                        .style("fill", (d, i, elements) => {
                                            return continentColorScale(d.value.continent);
                                        })

                                })

                            line.transition()
                                .duration(250)
                                //.delay((d, i) => i * 200)
                                .attr("class", "line")
                                .attr("fill", "none")
                                .attr("stroke-width", Chart.STROKE_WIDTH)
                                .attr("d", function (d) {
                                    return d3.line()
                                        .x(d => x(new Date(d.date)))
                                        .y(d => y(d.total_cases))
                                        (d.values)
                                })
                                .attr("stroke", d => colorScale(d.key))
                            return line;
                        },
                        function (update) {
                            return update
                                .attr("d", function (d) {
                                    return d3.line()
                                        .x(d => x(new Date(d.date)))
                                        .y(d => y(d.total_cases))
                                        (d.values)
                                }).attr("stroke", (d, i) => colorScale(i));
                        },
                        function (exit) {
                            return exit
                                //.transition()
                                //.duration(1000)
                                // .attr("stroke", "white")
                                .remove();
                        })
            }

            update_legend(data, colorScale, onClickFunction) {
                const SPACE_OF_ELEMENTS = 5;
                const NUMBER_OF_ELEMENTS_PER_COLUMN = 30;
                const SPACE_BETWEEN_ROWS = 20;
                const SPACE_BETWEEN_COLUMNS = 150;
                const CIRCLE_HORZ_OFFSET = 30;
                const TEXT_HORZ_OFFSET = 40;
                const CIRCLE_RADIUS = 6;
                const MAX_LABEL_LENGTH = 15;
                var circleColumnCounter = -1;
                var textColumnCounter = -1;

                var _this = this;
                var legend = Chart.svg
                    .selectAll('g.legend')
                    .data(data, d => d.key)
                    .join(
                        function (enter) {

                            Chart.back_elements = { data: data, colorScale: colorScale, onClickFunction: onClickFunction };

                            var legend_element_container =
                                enter.append("g")
                                    .attr("class", "legend")
                                    .on("mouseover", function (m, s) {

                                        var hoveredCircle = d3.select(this).select("circle");
                                        const ORIGINAL_COLOR = hoveredCircle.style("fill");
                                        const ORIGINAL_STROKE_WIDTH = hoveredCircle.attr("stroke-width");

                                        var lines = Chart.svg.selectAll(".line")
                                            .attr("stroke", (d) => d.key == s.key ? ORIGINAL_COLOR : "#f1f1f1")
                                            .attr("stroke-width", (d) => d.key == s.key ? Chart.STROKE_WIDTH_ON_HOVER : Chart.STROKE_WIDTH)

                                        lines.filter(d => (d.key == s.key)).raise()

                                        Chart.svg.selectAll(".legendText")
                                            .style("fill", (d) => d.key == s.key ? "black" : "#f1f1f1")
                                            .style("font-weight", (d) => d.key == s.key ? "bold" : "normal")

                                        Chart.svg.selectAll(".legendCircle").style("fill", (d) => d.key == s.key ? ORIGINAL_COLOR : "#f1f1f1")

                                        //Highlight scatter plot
                                        d3.selectAll(".scatterPlotPoint")
                                            .style("fill", (d, i, elements) => {
                                                const isSameContinent = d.value.continent == s.key;
                                                const isSameCountry = (d.key == s.key);
                                                // Additionally check if s.key==World, to prevent updating points when hovering over world plot.
                                                return (isSameContinent || isSameCountry || s.key == "World") ? d3.select(elements[i]).style("fill") : "#f1f1f1";
                                            })



                                    })
                                    .on("mouseout", function () {
                                        //Reset all line colors
                                        Chart.svg.selectAll(".line")
                                            .attr("stroke-width", Chart.STROKE_WIDTH)
                                            .attr("stroke", (d, i) => colorScale(d.key));
                                        Chart.svg.selectAll(".legendText")
                                            .style("fill", "black")
                                            .style("font-weight", "normal");
                                        Chart.svg.selectAll(".legendCircle").style("fill", (d, i) => colorScale(d.key));

                                        //Reset scatter plot
                                        d3.selectAll(".scatterPlotPoint")
                                            .style("fill", (d, i, elements) => {
                                                return continentColorScale(d.value.continent);
                                            })

                                    })
                                    .on("click", function (d, i) {
                                        onClickFunction(i.key)
                                    })

                            legend_element_container.append("circle")
                                .attr("class", "legendCircle")
                                .attr("cx", (d, i) => {
                                    circleColumnCounter = ((i) % NUMBER_OF_ELEMENTS_PER_COLUMN == 0) ? circleColumnCounter + 1 : circleColumnCounter;
                                    return Chart.X_MAX + CIRCLE_HORZ_OFFSET + (circleColumnCounter * SPACE_BETWEEN_COLUMNS);
                                })
                                .attr('cy', (d, i) => {
                                    var rotating_index = (i) % NUMBER_OF_ELEMENTS_PER_COLUMN;
                                    return ((rotating_index) * SPACE_BETWEEN_ROWS + (Chart.Y_MAX / 2) - data.length * SPACE_OF_ELEMENTS)
                                })
                                .attr("r", CIRCLE_RADIUS)
                                .style("fill", d => colorScale(d.key))
                            legend_element_container.append("text")
                                .attr("class", "legendText")
                                .attr("x", (d, i) => {
                                    textColumnCounter = ((i) % NUMBER_OF_ELEMENTS_PER_COLUMN == 0) ? textColumnCounter + 1 : textColumnCounter;
                                    return Chart.X_MAX + TEXT_HORZ_OFFSET + (textColumnCounter * SPACE_BETWEEN_COLUMNS);
                                })
                                .attr('y', (d, i) => {
                                    var rotating_index = (i) % NUMBER_OF_ELEMENTS_PER_COLUMN;
                                    return ((rotating_index) * SPACE_BETWEEN_ROWS + CIRCLE_RADIUS + (Chart.Y_MAX / 2) - data.length * SPACE_OF_ELEMENTS)
                                })
                                .attr("text-anchor", "start")
                                .text(d => d.key.length > MAX_LABEL_LENGTH ? d.key.slice(0, MAX_LABEL_LENGTH) + "..." : d.key)
                        },
                        function (exit) {
                            exit.remove()
                        }
                    )

            }

            update_back_button(data, colorScale, onClickFunction, title) {
                Chart.prevData.push({ data: data, colorScale: colorScale, onClickFunction: onClickFunction, title: title });

                if (Chart.layoutIndex == 0) {
                    Chart.button
                        .style("visibility", "hidden");
                } else {
                    Chart.button
                        .style("visibility", "visible");
                }
                var _this = this;
                Chart.button.on("click", function () {
                    Chart.layoutIndex -= 2;
                    var prevData = Chart.prevData[Chart.layoutIndex];
                    _this.draw_line(prevData.data, prevData.colorScale, prevData.onClickFunction, prevData.title)
                });

                Chart.layoutIndex++;

            }
        }

        function displayCovidCasesWorld() {
            var filtered = raw_data.filter(d => d.iso_code == "OWID_WRL");
            var continentData = new Map()
            continentData.set("World", filtered)
            var finalData = Array.from(continentData, function (item) {
                return { key: item[0], values: item[1] }
            });
            var colorScale = d3.scaleOrdinal().domain([finalData]).range(d3.schemeSet3);

            covidCasesGraph.draw_line(finalData, colorScale, displayCovidCasesPerContinent, "COVID-19 cases over time");

        }

        function displayCovidCasesPerContinent() {

            const ISO_CODES = ["OWID_ASI", "OWID_AFR", "OWID_EUR", "OWID_NAM", "OWID_SAM", "OWID_OCE"];
            const continents = ["Asia", "Africa", "Europe", "North America", "South America", "Oceania"];


            var filtered = raw_data.filter(d => ISO_CODES.includes(d.iso_code));

            var continentCovidDataMap = d3.group(filtered, d => d.iso_code)

            var continentData = new Map()
            for (let i = 0; i < ISO_CODES.length; i++) {
                continentData.set(continents[i], continentCovidDataMap.get(ISO_CODES[i]))
            }

            var finalData = Array.from(continentData, function (item) {
                return { key: item[0], values: item[1] }
            });

            finalData.sort((x, y) => d3.ascending(x.key, y.key));


            covidCasesGraph.draw_line(finalData, continentColorScale, displayCovidCasesPerCountry, "COVID-19 cases over time, per continent");

        }

        function displayCovidCasesPerCountry(continent) {

            var filtered = raw_data.filter(d => d.continent == continent);
            var countryCovidDataMap = d3.group(filtered, d => d.location)
            var colorScale = d3.scaleOrdinal().domain([countryCovidDataMap.keys()]).range(d3.schemeSet3);

            var countryData = new Map()
            countryCovidDataMap.forEach(function (val, key) {
                countryData.set(key, val)
            })
            var finalData = Array.from(countryData, function (item) {
                return { key: item[0], values: item[1] }
            });
            covidCasesGraph.draw_line(finalData, colorScale, displayVaccinesGraph, "COVID-19 cases over time in " + continent)

        }

        function displayVaccinesGraph(continent) {
            console.log("Displaying vaccine graph")
        }
        function displayWeathVsCasesScatterPlot() {

            // Process data to get data grouped per country, while removing non-country rows
            var maxDate = new Date(d3.max(raw_data, d => new Date(d.date)))
            var filtered = raw_data
                .filter(d => new Date(d.date).getTime() === maxDate.getTime())
                .filter(d => !d.iso_code.includes("OWID"))
                .filter(d => d.gdp_per_capita > 0)//50,000,000

            // .filter(d => d.gdp_per_capita < 100000)//50,000,000
            // .filter(d => d.total_cases < 50000000)//50,000,000

            var countryCovidDataMap = d3.group(filtered, d => d.location)

            var continents = Array.from(d3.group(filtered, d => d.continent).keys()).sort((x, y) => d3.ascending(x, y))

            var countryData = new Map()
            countryCovidDataMap.forEach(function (val, key) {
                countryData.set(key, val[0])
            })
            var data = Array.from(countryData, function (item) {
                return { key: item[0], value: item[1] }
            });

            continentColorScale = d3.scaleOrdinal().domain([data]).range(d3.schemeSet3);

            // Initialise graph 

            // Set Dimensions
            X_SIZE = 1550;
            Y_SIZE = 750;
            X_MARGIN = 350;
            Y_MARGIN = 50;

            X_MAX = X_SIZE - X_MARGIN * 2;
            Y_MAX = Y_SIZE - Y_MARGIN * 2;
            STROKE_WIDTH = 3.5;
            STROKE_WIDTH_ON_HOVER = 6.5

            // Append SVG Object to the Page
            var svg = d3.select("body")
                .append("svg")
                .attr('width', X_SIZE)
                .attr('height', Y_SIZE)
                .append("g")
                .attr("transform", "translate(" + X_MARGIN + "," + Y_MARGIN + ")");

            svg.append("text")
                .attr("transform", "translate(" + (X_MAX) / 2 + "," + -20 + ")")
                .attr("font-size", "24px")
                .text("Relation between the relative 'wealth' of a population and the evolution of the pandemic.")
                .style("text-anchor", "middle");

            // Create extents
            var flattened_data = [].concat.apply([], data.map(e => e.value));
            var xExtent = d3.extent(flattened_data, d => parseInt(d.gdp_per_capita))
            var yExtent = d3.extent(flattened_data, d => parseInt(d.total_cases));

            const numberOfVerticalTicks = 6;
            const numberOfHorizontalTicks = 7;

            // X Axis
            var x = d3.scaleLog()
                .base(2)
                .domain([xExtent[0], xExtent[1]])
                .range([0, X_MAX]);

            //Bottom  
            svg.append("g")
                .attr("class", "bottom_axis")
                .call(d3.axisBottom(x).ticks(numberOfVerticalTicks))
                .attr("transform", "translate(0, " + Y_MAX + ")")
                .append("text")
                .attr("x", X_MAX / 2)
                .attr("y", 40)
                .attr("text-anchor", "middle")
                .attr("stroke", "black")
                .text("GDP per capita");

            // Y Axis
            var y = d3.scaleLog()
                .domain([yExtent[0], yExtent[1]])
                .range([Y_MAX, 0])
                .base(10)

            svg.append("g")
                .attr("class", "left_axis")
                .call(d3.axisLeft(y).ticks(numberOfHorizontalTicks))
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -(Y_MAX / 2))
                .attr("y", -25)
                .attr("dy", "-5.1em")
                .attr("text-anchor", "middle")
                .attr("stroke", "black")
                .text("Covid Cases");

            //Gridlines
            svg.selectAll("horizontalGridline").data(y.ticks(numberOfHorizontalTicks)).enter()
                .append("line")
                .attr("x1", 0)
                .attr("x2", X_MAX)
                .attr("y1", d => y(d))
                .attr("y2", d => y(d))
                .attr("stroke", "#d3d3d3")
                .attr("stroke-width", "0.5px");

            svg.selectAll("verticalGridline").data(x.ticks(numberOfVerticalTicks)).enter()
                .append("line")
                .attr("x1", d => x(d))
                .attr("x2", d => x(d))
                .attr("y1", 0)
                .attr("y2", Y_MAX)

                .attr("stroke", "#d3d3d3")
                .attr("stroke-width", "0.5px");

            // Add Info Box
            const detailBoxHorzOffset = 10;
            const detailBoxHeight = 75;
            const detailBoxWidth = 200;
            const spaceBetweenTextRows = 20;

            var button = svg.append("g")
                .attr("transform", "translate(" + X_MAX + "," + 5 + ")")
            button.append("rect")
                .attr("height", detailBoxHeight)
                .attr("width", detailBoxWidth)
                .attr("fill", "#e7e7e7")
                .style("stroke", "black")
                .style("stroke-width", "1");
            button.append("text")
                .text("Click on a datapoint")
                .attr("dy", "0.2em")
                .style("text-anchor", "middle")
                .attr("x", (detailBoxWidth / 2))
                .attr("y", (detailBoxHeight / 2) - spaceBetweenTextRows);
            button.append("text")
                .text("for more information.")
                .attr("dy", "0.2em")
                .style("text-anchor", "middle")
                .attr("x", (detailBoxWidth / 2))
                .attr("y", (detailBoxHeight / 2) + spaceBetweenTextRows);

            // Add dots
            const dotRadius = 3.5;
            const selectedDotRadius = 5;
            svg.append('g')
                .selectAll("dot")
                .data(data, d => d.key)
                .join("circle")
                .attr("class", "scatterPlotPoint")
                .attr("cx", (d) => x(d.value.gdp_per_capita))
                .attr("cy", (d) => y(d.value.total_cases))
                .attr("r", 3.5)
                .style("fill", (d, i) => continentColorScale(d.value.continent))
                .on("mouseover", function (m, s) {

                    //Emphasise hovered element
                    var hoveredCircle = d3.select(this);
                    const ORIGINAL_COLOR = hoveredCircle.style("fill");
                    svg.selectAll(".scatterPlotPoint")
                        .style("fill", (d) => d.key == s.key ? ORIGINAL_COLOR : "#f1f1f1")
                        .attr("r", (d) => d.key == s.key ? selectedDotRadius : dotRadius)
                    hoveredCircle.raise(); //Display on top

                    //Emphasise on legend
                    svg.selectAll(".legendText")
                        .style("fill", (d) => {
                            return d == s.value.continent ? "black" : "#f1f1f1"
                        })
                        .style("font-weight", (d) => d == s.value.continent ? "bold" : "normal")
                    svg.selectAll(".legendCircle").style("fill", (d) => d == s.value.continent ? ORIGINAL_COLOR : "#f1f1f1")

                    //Update info box
                    button.selectAll("text").remove()
                    button.append("text")
                        .text(s.value.location)
                        .attr("dy", "0.2em")
                        .style("text-anchor", "middle")
                        .style("font-weight", "bold")
                        .attr("x", (detailBoxWidth / 2))
                        .attr("y", (detailBoxHeight / 2) - spaceBetweenTextRows);

                    button.append("text")
                        .text("GDP per capita: " + s.value.gdp_per_capita)
                        .attr("dy", "0.2em")
                        .style("text-anchor", "middle")
                        .attr("x", (detailBoxWidth / 2))
                        .attr("y", (detailBoxHeight / 2));
                    button.append("text")
                        .text("Covid Cases: " + s.value.total_cases)
                        .attr("dy", "0.2em")
                        .style("text-anchor", "middle")
                        .attr("x", (detailBoxWidth / 2))
                        .attr("y", (detailBoxHeight / 2) + spaceBetweenTextRows);

                    //Emphasise on line graph
                    var lines = d3.selectAll(".line")
                        .attr("stroke", (d, i, elements) => {
                            const isSameContinent = d.key == s.value.continent;
                            const isSameCountry = d.key == s.key;
                            d.originalColor = d3.select(elements[i]).attr("stroke");
                            return (isSameContinent || isSameCountry || d.key == "World") ? d.originalColor : "#f1f1f1"
                        })
                })
                .on("mouseout", function (m, s) {
                    //Reset all scatter points
                    svg.selectAll(".scatterPlotPoint")
                        .attr("r", dotRadius)
                        .style("fill", (d, i) => {
                            return continentColorScale(d.value.continent)
                        });
                    //Reset legend
                    svg.selectAll(".legendText")
                        .style("fill", "black")
                        .style("font-weight", "normal");
                    svg.selectAll(".legendCircle").style("fill", (d, i) => continentColorScale(d));

                    //Reset  line graph
                    var lines = d3.selectAll(".line")
                        .attr("stroke", (d) => {
                            return d.originalColor
                        })
                    // .attr("stroke-width", (d, i, elements) => {
                    //     return (isSameContinent || isSameContinent) ? Chart.STROKE_WIDTH_ON_HOVER : d3.select(elements[i]).attr("stroke-width");
                    // })

                })



            //Legend
            const SPACE_OF_ELEMENTS = 5;
            const NUMBER_OF_ELEMENTS_PER_COLUMN = 30;
            const SPACE_BETWEEN_ROWS = 20;
            const SPACE_BETWEEN_COLUMNS = 150;
            const CIRCLE_HORZ_OFFSET = 30;
            const TEXT_HORZ_OFFSET = 40;
            const CIRCLE_RADIUS = 6;
            const MAX_LABEL_LENGTH = 15;
            var circleColumnCounter = -1;
            var textColumnCounter = -1;
            var legend = svg
                .selectAll('g.legendScatter')
                .data(continents)
                .join(
                    function (enter) {

                        var legend_element_container =
                            enter.append("g")
                                .attr("class", "legendScatter")
                                .on("mouseover", function (m, s) {

                                    var hoveredCircle = d3.select(this).select("circle");
                                    const ORIGINAL_COLOR = hoveredCircle.style("fill");
                                    var points = svg.selectAll(".scatterPlotPoint")
                                        .style("fill", (d) => {
                                            return d.value.continent == s ? ORIGINAL_COLOR : "#f1f1f1"
                                        })

                                    points.filter(d => (d.value.continent == s)).raise()

                                    svg.selectAll(".legendText")
                                        .style("fill", (d) => d == s ? "black" : "#f1f1f1")
                                        .style("font-weight", (d) => d == s ? "bold" : "normal")
                                    svg.selectAll(".legendCircle").style("fill", (d) => {
                                        return d == s ? ORIGINAL_COLOR : "#f1f1f1"
                                    })
                                    //Emphasise on line graph
                                    var lines = d3.selectAll(".line")
                                        .attr("stroke", (d, i, elements) => {
                                            const isSameContinent = d.key == s;
                                            const isSameCountry = d.values[0].continent == s;
                                            d.originalColor = d3.select(elements[i]).attr("stroke");
                                            return (isSameContinent || isSameCountry || d.key == "World") ? d.originalColor : "#f1f1f1"
                                        })
                                })
                                .on("mouseout", function () {
                                    //Reset scatter plot
                                    svg.selectAll(".scatterPlotPoint")
                                        .style("fill", (d, i) => continentColorScale(d.value.continent));
                                    svg.selectAll(".legendText")
                                        .style("fill", "black")
                                        .style("font-weight", "normal");
                                    svg.selectAll(".legendCircle").style("fill", (d, i) => {
                                        return continentColorScale(d);
                                    })

                                    //Reset line graph
                                    var lines = d3.selectAll(".line")
                                        .attr("stroke", (d, i, elements) => {
                                            return d.originalColor;
                                        })


                                })

                        legend_element_container.append("circle")
                            .attr("class", "legendCircle")
                            .attr("cx", (d, i) => {
                                return X_MAX + CIRCLE_HORZ_OFFSET;
                            })
                            .attr('cy', (d, i) => {
                                return (i * SPACE_BETWEEN_ROWS + (Y_MAX / 2) - continents.length * SPACE_OF_ELEMENTS)
                            })
                            .attr("r", CIRCLE_RADIUS)
                            .style("fill", d =>
                                continentColorScale(d)
                            )
                        legend_element_container.append("text")
                            .attr("class", "legendText")
                            .attr("x", (d, i) => {
                                return X_MAX + TEXT_HORZ_OFFSET;
                            })
                            .attr('y', (d, i) => {
                                return (i * SPACE_BETWEEN_ROWS + CIRCLE_RADIUS + (Y_MAX / 2) - continents.length * SPACE_OF_ELEMENTS)
                            })
                            .attr("text-anchor", "start")
                            .text((d, i) => {
                                return d;
                            })
                    },
                    function (exit) {
                        exit.remove()
                    }
                )


        }


        d3.csv('https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv')
            .then(function (data) {
                window.covidCasesGraph = new Chart();
                window.raw_data = data; //global data;
            })
            .then(displayCovidCasesWorld)
            .then(displayWeathVsCasesScatterPlot);
    </script>
</body>

</html>