<!DOCTYPE html>
<html lang="en">
<!-- 
    This is F21DV: Data Visualisation & Analytics Lab 4.

    The purpose of this project is to visualise information surrounding content available on Netflix.
 -->

<head>
    <meta charset="utf-8">
    <title>Lab 4 - Netflix Visualisations</title>
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,500,800" rel="stylesheet">

    <style>
        body {
            background-color: #232323;
        }

        .axis path,
        line {
            stroke: white !important;
        }

        .axis text {
            fill: white !important
        }

        .widgetBackground {
            fill: #151515;
        }

        .widgetTitle {
            font-family: Montserrat;
            text-anchor: middle;
            font-size: 25px;
            fill: #151515;
        }

        .blackBorder {
            text-shadow: -1px 1px 0 #000,
                1px 1px 0 #000,
                1px -1px 0 #000,
                -1px -1px 0 #000;

        }
    </style>
</head>

<body>
    <script src='https://d3js.org/d3.v7.js'></script>
    <script src='https://unpkg.com/simple-statistics@7.7.5/dist/simple-statistics.min.js'></script>
    <script type="text/javascript" src="jsonfn.js"></script>


    <!-- This is a web worker, which runs in the background. The below code is quite intensive, so running it in the background prevents the application
                    from being haulted during its execution.
                     -->

    <script id="worker" type="javascript/worker">
    window = self; // jsonfn uses "window"
    importScripts("https://cdn.jsdelivr.net/gh/vkiryukhin/jsonfn/jsonfn.js");
    importScripts("https://d3js.org/d3.v7.js");

        self.onmessage = (message) =>{

            var content = message.data.content;
            var mapData = message.data.mapData;
            var path = JSONfn.parse(message.data.path);
            var year = message.data.year;
            var countryCentroids = mapCentroidsToData(content, mapData, year)
            self.postMessage(countryCentroids)

        }
         function mapCentroidsToData(content, mapData, year) {
            const X_SIZE = 850;
            const Y_SIZE = 600;
            const X_MARGIN = 50;
            const Y_MARGIN = 50;

            const X_MAX = X_SIZE - (X_MARGIN * 2);
            const Y_MAX = Y_SIZE - (Y_MARGIN * 2);
            const MAP_VERT_OFFSET = 30;
            const TITLE_VERT_OFFSET = 25;
            const projection = d3.geoMercator()
                .scale(160)
                .center([0, 60])
                .translate([X_MAX / 2, 200]);
            const path = d3.geoPath(projection);


            //Create country centroids
            var countryCentroids = new Map(d3.filter((mapData.features.map(d => {
                const centroid = path.centroid(d.geometry);
                const topContentForCountry = getTopContent(content, d.properties.name, 1).get(year)[0];
                return [
                    d.properties.name, {
                        centroid: { x: centroid[0], y: centroid[1] },
                        topContent: topContentForCountry
                    }]
            })), d => d[1]["topContent"] != undefined));

            return countryCentroids
        }

        function getTopContent(contentData, region, number) {
            var yearExtents = d3.extent(contentData, d => new Date(d["Netflix Release Date"]).getFullYear())
            var months = ["January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"];
            var monthName = new Intl.DateTimeFormat("en-US", { month: "long" }).format;

            var topContentPerMonth = new Map();
            for (let year = yearExtents[0]; year < yearExtents[1]; year++) { var filtered=(region==null) ? contentData
        .filter(d=> d["Boxoffice"] != "")
        .filter(d => new Date(d["Netflix Release Date"]).getFullYear() == year)
        : contentData
        .filter(d => d["Boxoffice"] != "")
        .filter(d => new Date(d["Netflix Release Date"]).getFullYear() == year)
        .filter(d => d["Country Availability"].includes(region))

        var top10 = filtered.sort((a, b) => d3.descending(+a["IMDb Score"], +b["IMDb Score"])).slice(0, number);

        topContentPerMonth.set(year, top10);
        }
        return topContentPerMonth;

        }


    </script>
    <script>

        const widgetBackgroundColor = "#151515";

        const defaultMapColor = "#373737"
        const netflixColor = "#ce0812"//"#E50914"
        const netflixColorDarker = "#6e1115"
        const netflixColorDarkerLight = "#a0060e"
        const white = "#F5F5F1"
        const whiteDarker = "#c4c4c0"

        const grey = "#4e4b4b"
        const darkGrey = "#221F1F"
        const HEADER_WIDTH = 35
        const WIDGET_CORNER_RADIUS = 25;

        // Line graph scales are global so that they can be accessed by mouse event functions.
        var lineGraphXScale;
        var lineGraphYScale;

        /**
         * Converts an array of Netflix subscribers into a Map<Country,Subscriber Information>
         */
        function subscriberArrayToMap(netflixSubscribersByCountry) {
            var map = (d3.group(netflixSubscribersByCountry, d => d.Country));
            map.forEach((element, key) => {
                map.set(key, element[0])
            })

            return map

        }

        /**
         * Performs preprocessing to link country names between datasets. This is not extensive
         * and could be extended in the future.
         */
        function linkCountryNaming(mapData, netflixSubscribersByCountry) {

            mapData.features.forEach(element => {
                element.properties.name = element.properties.name.trim()
            })

            netflixSubscribersByCountry.forEach(element => {
                element.Country = element.Country.trim()
            })
            mapData.features.forEach(element => {
                switch (element.properties.name) {
                    case "USA":
                        element.properties.name = "United States"
                        break;
                    case "England":
                        element.properties.name = "United Kingdom"
                        break;
                    case "Slovakia":
                        element.properties.name = "Slovak Republic"
                        break;
                    default:
                        break;
                }
            });

        }

        /**
         * Displays geographic map, where countries are coloured based on number of Netflix subscribers.
         */
        function displayMap(mapData, subscriberData) {
            const X_SIZE = 850;
            const Y_SIZE = 600;
            const X_MARGIN = 50;
            const Y_MARGIN = 50;

            const X_MAX = X_SIZE - (X_MARGIN * 2);
            const Y_MAX = Y_SIZE - (Y_MARGIN * 2);
            const MAP_VERT_OFFSET = 30;
            const TITLE_VERT_OFFSET = 25;
            const projection = d3.geoMercator()
                .scale(160)
                .center([0, 60])
                .translate([X_MAX / 2, 200]);
            const path = d3.geoPath(projection);

            var g = d3.select("svg").append("g")
                .attr("class", "subscriberMap")


            g.append("rect")
                .attr("class", "widgetBackground")
                .attr("width", X_SIZE)
                .attr("height", (Y_SIZE + HEADER_WIDTH))
                .attr("rx", WIDGET_CORNER_RADIUS)
                .attr("ry", WIDGET_CORNER_RADIUS)

            g.append("path")
                .attr("class", "widgetHeader")
                .attr("d", roundedRect(0, 0, X_SIZE, HEADER_WIDTH, 25, true, true, false, false))
                .style("fill", "url(#redTitleGradient)")

            g.append("text")
                .attr("class", "widgetTitle")
                .text("Netflix Total Subscribers & Top Available Content Per Region")
                .attr("transform", "translate(" + (X_SIZE / 2) + "," + TITLE_VERT_OFFSET + ")")

            var innerSvg = d3.select(".subscriberMap")
                .append("svg")
                .attr("y", HEADER_WIDTH)
                .attr("width", X_SIZE)
                .attr("height", Y_SIZE)
                .attr("class", "map")


            var paths = innerSvg.selectAll("path")
                .data(mapData.features)
                .enter()
                .append("path")
                .attr("class", "country")
                .attr("id", (d) => d.properties.name)
                .attr("d", (d) => path(d))
                .attr("fill", defaultMapColor)
                .style("stroke", "black")
                .style("stroke-width", 0);


            const extents = getSubscriberExtentsAcrossQuarters(subscriberData);
            const quarters = subscriberData.columns.filter(column => column.includes("# of Subscribers"))


            const colourScale = d3.scaleLinear()
                .domain(extents)
                .range(["#4D3233", netflixColor])

            paths
                .attr("fill", (d) => { // colours don't change noticeably between datasets, so it is appropriate to
                    const col = setCountryColour(d, // only use a single color here.
                        subscriberData,
                        colourScale,
                        "# of Subscribers Q4 2021 (Estimate)")

                    return col;

                })
            return path;
        }

        /**
         * Gets the extends of Netflix subscribers across different quarters (ie. dates)
         */
        function getSubscriberExtentsAcrossQuarters(subscriberData) {

            const quarters = subscriberData.columns.filter(column => column.includes("# of Subscribers"))

            var subscriberExtents = [];
            quarters.forEach(quarter => {
                const quarterExtents = d3.extent(subscriberData, (d) => {
                    return +d[quarter]
                })

                subscriberExtents =
                    [d3.min([subscriberExtents[0], quarterExtents[0]]),
                    d3.max([subscriberExtents[1], quarterExtents[1]])]

            })
            return subscriberExtents

        }

        /**
         * Sets the country colour on the map, based on the number of Netflix subscribers in the country.
         */
        function setCountryColour(country, subscriberData, colourScale, field) {


            const subscriberDataForCountry = subscriberData.filter(data => {
                return country.properties.name === data.Country
            });

            if (subscriberDataForCountry.length != 0) {
                const numberOfSubscribers = +subscriberDataForCountry[0][field]
                return colourScale(numberOfSubscribers)

            } else {
                return defaultMapColor
            }
        }

        /**
         * Displays the top rated content available in each country.
         * This bubbles are hoverable, highlighting related bubbles/elements in other graphs.
         */
        function displayTopContentBubbles(countryCentroids, content, mapData, path, year, boxOfficeExtents) {


            const maxRadius = 40;


            // Get extents (upper-lower limits) of total cases.
            // var extent = d3.extent(countryCentroids.values(), d => +d["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, ''))
            // Create radius scale.
            var radiusScale = d3.scaleLog()
                .domain([1, boxOfficeExtents[1]])
                .range([0, maxRadius])
                .clamp(true)

            var bubbles = d3.select("svg")
                .selectAll(".bubble")
                .data(countryCentroids, d => {
                    return d[0]
                })
                .join(
                    enter => {

                        var g = enter.append("g").attr("class", "bubble")
                            .on("mouseover", function (e, d) {
                                displayBubblePopup(e, d, this)
                                highlightContent(d[1].topContent)
                            })
                            .on("mouseout", function (e, d) {
                                removeBubblePopup();
                                resetAllContent();

                            })
                        g.append("circle")
                            .attr("cx", d => {
                                return (d[1].centroid.x + radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))
                            })
                            .attr("cy", d => {
                                return (d[1].centroid.y + radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))
                            })
                            .attr("r", d => {
                                var boxoffice = +d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '');
                                var radius = radiusScale(boxoffice);
                                return radius
                            })
                            .attr("fill", "none")
                            .attr("stroke", "black")
                            .attr('pointer-events', 'none')

                        g.append("clipPath")
                            .attr("id", d => "bubblePath" + d[0].split(" ").join(""))
                            .append("circle")
                            .attr("cx", d => {
                                return (d[1].centroid.x + radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))
                            })
                            .attr("cy", d => {
                                return (d[1].centroid.y + radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))
                            })
                            .attr("r", d => {
                                var boxoffice = +d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '');
                                var radius = radiusScale(boxoffice);
                                return radius
                            })
                            .attr('pointer-events', 'none')

                        g.append("image")
                            .attr("x", d => {
                                return (d[1].centroid.x - (radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')) / 2))
                            })
                            .attr("y", d => {
                                return d[1].centroid.y - radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, ''))
                            })
                            .attr("clip-path", d => "url(#bubblePath" + d[0].split(" ").join("") + ")")

                            .attr("width", (maxRadius * 2))
                            .attr('xlink:href', d => d[1]["topContent"]["Image"])
                            .style("opacity", 0.7)


                    },
                    update => {
                        update.select("clipPath").select("circle")
                            .transition()
                            .duration(500)
                            .attr("r", d => radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))
                        update.select("circle")
                            .transition()
                            .duration(500)
                            .attr("r", d => radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))

                        update
                            .select("image")
                            .attr('xlink:href', d => d[1]["topContent"]["Image"])
                    },
                    exit => {
                        return exit.remove();
                    })


        }


        /**
         * Displays a mouse-hover pop-up, providing more information concerning a piece of Netflix media.
         */
        function displayBubblePopup(e, d, thisElement = this) {
            const popupWidth = 510, popupHeight = 270;
            const titleBarHeight = 30;
            const horzOffset = 100, vertOffset = -60;
            const titleOffset = 13;
            const infoOffset = 42;
            const newLineOffset = 22;

            const titleTextDelay = 50;
            const infoTextDelay = 350;
            const textDuration = 250;
            const bubbleDuration = 350;
            const mainBubbleDelay = 200;

            const titleFontSize = "20px";
            const infoFontSize = "17px";
            const elementClass = d3.select(thisElement).attr("class");
            const textX = 10;
            const imageX = 320;
            const imageY = -5;
            const imageHeightOffset = 15;
            const bubbleCentroid = { x: d3.pointer(e, d3.select("svg"))[0], y: d3.pointer(e, d3.select("svg"))[1] } //need to pass svg as target to mouse event due to transformed rects.
            var movieData = (elementClass == "bubble") ? d[1].topContent : d;
            var g = d3.select("svg")
                .append("g")
                .raise()
                .attr("class", "bubblePopup")
                // If cursor is on far right of page, move to left of cursor. Else move to right.
                .attr("transform", "translate(" + ((bubbleCentroid.x > 1600) ? bubbleCentroid.x - popupWidth - horzOffset : bubbleCentroid.x + horzOffset)
                    + "," + (bubbleCentroid.y + vertOffset) + ")")

            g.append("path")
                .attr("d", roundedRect(0, titleBarHeight, popupWidth, 0, 6, false, false, true, true))
                .transition()
                .delay(mainBubbleDelay)
                .duration(bubbleDuration)
                .attr("d", roundedRect(0, titleBarHeight, popupWidth, popupHeight, 6, false, false, true, true))
                .style("fill", "url(#whiteGradient)")


            g.append("path")
                .attr("d", roundedRect(0, 0, popupWidth, 0, 6, true, true, false, false))
                .transition()
                .duration(bubbleDuration)
                .attr("d", roundedRect(0, 0, popupWidth, titleBarHeight, 6, true, true, false, false))
                .style("fill", "url(#redTitleGradient)")

            g.append("text")
                .attr("class", "popupTitle")
                .attr("x", (popupWidth / 2))
                .attr("y", titleOffset)
                .style("fill", "white")
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text(movieData["Title"])
                .transition()
                .duration(textDuration)
                .delay(titleTextDelay)
                .style("font-size", titleFontSize)


            var info = g.append("g")
                .attr("class", "popupInformation")
                .attr("transform", "translate(" + (0) + "," + (infoOffset) + ")")

            info.append("text")
                .attr("x", textX)
                .attr("y", 0)
                .style("font-family", "Montserrat")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text("Directed by:")
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)


            info.append("text")
                .attr("x", textX)
                .attr("y", newLineOffset)
                .style("font-family", "Montserrat")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .style("font-weight", "bold")
                .text((movieData["Director"].length > 30) ? movieData["Director"].slice(0, 30) + "..." : movieData["Director"])

                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", textX)
                .attr("y", newLineOffset * 2)
                .style("font-family", "Montserrat")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text("Genre(s):")
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            //Ensure every element after this point is a single comma seperated string.
            if (Array.isArray(movieData["Genre"])) {
                movieData["Genre"] = movieData["Genre"].join(", ");
            }

            info.append("text")
                .attr("x", textX)
                .attr("y", newLineOffset * 3)
                .style("font-family", "Montserrat")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .style("font-weight", "bold")
                .text((movieData["Genre"].length > 30) ? movieData["Genre"].slice(0, 30) + "..." : movieData["Genre"])
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", textX)
                .attr("y", newLineOffset * 4)
                .style("font-family", "Montserrat")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text("Release Date (Initial / Netflix):")
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", textX)
                .attr("y", newLineOffset * 5)
                .style("font-family", "Montserrat")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .style("font-weight", "bold")
                .text(new Date(movieData["Release Date"]).toISOString().split('T')[0] + " / " + new Date(movieData["Netflix Release Date"]).toISOString().split('T')[0])
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", textX)
                .attr("y", newLineOffset * 6)
                .style("font-family", "Montserrat")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text("IMDb Score:")
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", textX)
                .attr("y", newLineOffset * 7)
                .style("font-family", "Montserrat")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .style("font-weight", "bold")
                .text(+movieData["IMDb Score"])
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", textX)
                .attr("y", newLineOffset * 8)
                .style("font-family", "Montserrat")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text("Box office revenue:")
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", textX)
                .attr("y", newLineOffset * 9)
                .style("font-family", "Montserrat")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .style("font-weight", "bold")
                .text(movieData["Boxoffice"])
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", textX)
                .attr("y", newLineOffset * 10)
                .style("font-family", "Montserrat")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text("Awards received/nominated:")
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", textX)
                .attr("y", newLineOffset * 11)
                .style("font-family", "Montserrat")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .style("font-weight", "bold")
                .text(Math.trunc(+movieData["Awards Received"]) + "/" + Math.trunc(+movieData["Awards Nominated For"]))
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("image")
                .attr("x", imageX)
                .attr("y", imageY)
                .attr("xlink:href", movieData["Image"])
                .attr("height", (popupHeight - imageHeightOffset))
                .attr("opacity", 0)
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .attr("opacity", 1)



        }


        /**
         * Taken from https://stackoverflow.com/questions/12115691/svg-d3-js-rounded-corners-on-one-side-of-a-rectangle,
         * this function is used to create a rectangle with rounded corners - each corner being able to be individually rounded.
         */
        function roundedRect(x, y, w, h, r, tl, tr, bl, br) {
            var retval;
            retval = "M" + (x + r) + "," + y;
            retval += "h" + (w - 2 * r);
            if (tr) { retval += "a" + r + "," + r + " 0 0 1 " + r + "," + r; }
            else { retval += "h" + r; retval += "v" + r; }
            retval += "v" + (h - 2 * r);
            if (br) { retval += "a" + r + "," + r + " 0 0 1 " + -r + "," + r; }
            else { retval += "v" + r; retval += "h" + -r; }
            retval += "h" + (2 * r - w);
            if (bl) { retval += "a" + r + "," + r + " 0 0 1 " + -r + "," + -r; }
            else { retval += "h" + -r; retval += "v" + -r; }
            retval += "v" + (2 * r - h);
            if (tl) { retval += "a" + r + "," + r + " 0 0 1 " + r + "," + -r; }
            else { retval += "v" + -r; retval += "h" + r; }
            retval += "z";
            return retval;
        }

        /**
         * Removes the Netflix content mousehover popup.
         */
        function removeBubblePopup() {
            d3.selectAll(".bubblePopup")
                .transition()
                .duration(150)
                .style("opacity", 0)
                .remove();

        }
        /**
         * Creates various defs used throughout the application, ie. gradients and blurs.
         */
        function createDefs() {
            var redGradient = d3.select("svg").append("defs")
                .append("linearGradient")
                .attr("id", "redGradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%")
                .attr("spreadMethod", "pad");
            redGradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", netflixColor)
                .attr("stop-opacity", 1);
            redGradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", netflixColorDarker)
                .attr("stop-opacity", 1);

            var redTitleGradient = d3.select("svg").append("defs")
                .append("linearGradient")
                .attr("id", "redTitleGradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%")
                .attr("spreadMethod", "pad");
            redTitleGradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", netflixColor)
                .attr("stop-opacity", 1);
            redTitleGradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", netflixColorDarkerLight)
                .attr("stop-opacity", 1);

            var whiteGradient = d3.select("defs")
                .append("linearGradient")
                .attr("id", "whiteGradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%")
                .attr("spreadMethod", "pad");
            whiteGradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", white)
                .attr("stop-opacity", 1);
            whiteGradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", whiteDarker)
                .attr("stop-opacity", 1);


            var greyGradient = d3.select("defs")
                .append("linearGradient")
                .attr("id", "greyGradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%")
                .attr("spreadMethod", "pad");
            greyGradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", grey)
                .attr("stop-opacity", 1);
            greyGradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", darkGrey)
                .attr("stop-opacity", 1);

            var blur = d3.select("defs")
                .append("filter")
                .attr("id", "blur")
                .append("feGaussianBlur")
                .attr("stdDeviation", 1.5);


        }

        /**
         * Instatiates graph container and axis.
         */
        function initGraph(graphPos, graphClass) {

            var g = d3.select("svg").append("g")
                .attr("class", graphClass)
                .attr("transform", "translate(" + graphPos[0] + "," + graphPos[1] + ")")

            g.append("g").attr("id", "bottomAxis")
            g.append("g").attr("id", "leftAxis")


        }

        /**
         * Draws the highest rated IMDb content onto the graph.
         * The bars are hoverable, highlighting the bar/other associated elements in other graphs.
         */
        function drawHighestRatedGraph(content, graphTitle, width, height) {
            const TITLE_VERT_OFFSET = -50;
            const X_AXIS_LABEL_HEIGHT = 300;
            const Y_AXIS_LABEL_WIDTH = 70;
            var g = d3.select(".topContentBarGraph")
            g.selectAll(".widgetBack")
                .data([graphTitle])
                .join(
                    enter => {
                        var widget = enter.append("g").
                            attr("class", "widgetBack");

                        widget.append("rect")
                            .attr("class", "widgetBackground")
                            .attr("x", -Y_AXIS_LABEL_WIDTH)
                            .attr("y", TITLE_VERT_OFFSET)
                            .attr("width", width + Y_AXIS_LABEL_WIDTH)
                            .attr("height", (height + HEADER_WIDTH + X_AXIS_LABEL_HEIGHT))
                            .attr("rx", WIDGET_CORNER_RADIUS)
                            .attr("ry", WIDGET_CORNER_RADIUS)

                        widget.append("path")
                            .attr("class", "widgetHeader")
                            .attr("d", roundedRect(-Y_AXIS_LABEL_WIDTH, TITLE_VERT_OFFSET, width + Y_AXIS_LABEL_WIDTH, HEADER_WIDTH, 25, true, true, false, false))
                            .style("fill", "url(#redTitleGradient)")

                        widget.append("text")
                            .attr("class", "widgetTitle")
                            .text(d => d)
                            .attr("transform", "translate(" + ((width - Y_AXIS_LABEL_WIDTH) / 2) + "," + -25 + ")")


                    },
                    update => {
                        return update.select("text").text(d => d);
                    },
                    exit => {
                        return exit.remove();
                    })


            const titles = getTitles(content)

            const scoreExtents = d3.extent(content, d => +d["IMDb Score"])

            var xScale = d3.scaleBand().range([0, width]).domain(titles).padding(0.4);
            var yScale = d3.scaleLinear().range([0, height]).domain([scoreExtents[1], scoreExtents[0] - 0.1])

            g.select("g #bottomAxis")
                .raise()
                .attr("class", "axis")
                .attr("id", "bottomAxis")
                .attr("transform", "translate(0," + height + ")")
                .transition()
                .duration(1000)
                .call(d3.axisBottom(xScale))
                .selectAll("text")
                .attr("class", "barGraphXLabel")
                .attr("x", -15)
                .attr("y", -5)
                .style("text-anchor", "end")
                .style("font-size", "17px")
                .text(d => (d.length > 30) ? d.slice(0, 30) + "..." : d)

            g.select("g #bottomAxis").selectAll("text")
                .style("fill", "white")
                .attr("transform", "rotate(-90)")

            var yAxis = g.select("g #leftAxis")
                .raise()
                .attr("class", "axis")
                .attr("id", "leftAxis")
            yAxis.transition()
                .duration(1000)
                .call(d3.axisLeft(yScale).ticks(5))
                .selectAll("text")
                .style("fill", "white")
                .style("font-size", "14px")

            g.selectAll(".bar")

                .data(content)
                .join(
                    enter => {
                        var rect = enter.append("rect")
                            .attr("class", "bar")
                            .attr("x", d => xScale(d["Title"]))
                            .attr("y", d => height)
                            .attr("width", xScale.bandwidth())
                            .attr("height", 10)
                            .attr("fill", "url(#redGradient)")

                        rect.transition()
                            .duration(500)
                            .attr("height", d => height - yScale(+d["IMDb Score"]))
                            .attr("y", d => yScale(+d["IMDb Score"]))

                        rect
                            .on("mouseover", function (mouseInfo, data) {
                                highlightContent(data);
                                displayBubblePopup(mouseInfo, data, this)

                            })
                            .on("mouseout", (mouseInfo, data) => {
                                resetAllContent();
                                removeBubblePopup(mouseInfo);
                            })


                    },
                    update => {
                        update
                            .transition()
                            .duration(1000)
                            .attr("height", d => height - yScale(+d["IMDb Score"]))
                            .attr("y", d => yScale(+d["IMDb Score"]))

                    },
                    exit => {
                        exit.transition()
                            .remove();
                    }
                )
        }

        /**
         * High-level function to highlight content across graphs.
         */
        function highlightContent(content) {
            d3.selectAll(".bar")
                .transition()
                .duration(250)
                .style("fill-opacity", d => {
                    return d.Title == content.Title ? "1" : "0.4";
                })
            d3.selectAll(".barGraphXLabel")
                .transition()
                .duration(250)
                .style("fill-opacity", d => {
                    return d == content.Title ? "1" : "0.4";
                })

            d3.selectAll(".scatterPlotPoint")
                .style("fill-opacity", d => {
                    return d.Title == content.Title ? "1" : "0.2";
                })
                .attr("r", d => {
                    return d.Title == content.Title ? 8 : 1;
                })

            highlightBubbles(content.Title);
            drawContentReleaseLine(content)
        }

        /**
         * Draws the a vertical line onto the Netflix Subscriptions over time graph, placed horizontally
         * on the release date of the specified Netflix content.
         */
        function drawContentReleaseLine(content) {
            var g = d3.select(".lineGraph")
                .append("g")
                .attr("class", "selectedContentLine")
                .data([content])

            g.append("line")
                .attr("x1", lineGraphXScale(new Date(content["Netflix Release Date"])))
                .attr("y1", 0)
                .attr("x2", lineGraphXScale(new Date(content["Netflix Release Date"])))
                .attr("y2", 300)
                .style("stroke-dasharray", ("10, 10"))
                .attr("stroke-width", 2)

            g.append("text")
                .text(d => content.Title)
                .attr("x", lineGraphXScale(new Date(content["Netflix Release Date"])) + 10)
                .attr("class", "blackBorder")
                .style("fill", "white")
                .style("font-size", "17px")
                .style("alignment-baseline", "central")
                .style("font-family", "Montserrat")

        }
        /**
         * General purpose function to reset elements to default state - ie. after hover.
         */
        function resetAllContent() {
            d3.selectAll(".bar")
                .transition()
                .duration(250)
                .style("fill-opacity", 1);

            d3.selectAll(".barGraphXLabel")
                .transition()
                .duration(250)
                .style("fill-opacity", 1)
            d3.selectAll(".scatterPlotPoint")
                .style("fill-opacity", 1)
                .attr("fill", netflixColor)
                .attr("r", 1);

            resetBubbles();

            d3.selectAll(".selectedContentLine").transition().duration(500).style("opacity", 0).remove();

        }

        /**
         * Highlights the bubbles on the geographic map, while supressing others.
         */
        function highlightBubbles(title) {
            d3.selectAll(".bubble")
                .transition()
                .duration(250)
                .attr("opacity", d => {
                    return d[1].topContent.Title == title ? 1 : 0.6;
                })
                .select("circle")
                .attr("stroke", d => {
                    return d[1].topContent.Title == title ? "url(#redGradient)" : "black";
                })
                .attr("stroke-width", d => {
                    return d[1].topContent.Title == title ? "8px" : "1px";

                })

            d3.selectAll(".bubble")
                .selectAll("image")
                .transition()
                .duration(250)
                .style("opacity", d => {
                    return d[1].topContent.Title == title ? 1 : 0.7;
                })
                .attr("filter", d => {
                    return d[1].topContent.Title == title ? null : "url(#blur)";
                })

        }

        /**
         * Resets bubbles into their original state (ie. after hover).
         */
        function resetBubbles() {
            d3.selectAll(".bubble")
                .transition()
                .duration(500)
                .attr("opacity", 1)
                .select("circle")
                .attr("stroke", "black")
                .attr("stroke-width", "1px")

            d3.selectAll(".bubble")
                .selectAll("image")
                .transition()
                .duration(500)
                .style("opacity", 0.7)
                .attr("filter", null)
        }

        /**
         * Draws the box office success graph for a given year.
         * The bars are hoverable, highlighting the bar and other associated elements in other graphs.
         */
        function drawBoxOfficeSuccessGraph(content, graphTitle, width, height) {

            const TITLE_VERT_OFFSET = -50;
            const X_AXIS_LABEL_HEIGHT = 300;
            const Y_AXIS_LABEL_WIDTH = 70;
            var g = d3.select(".boxOfficeSucessGraph")
            g.selectAll(".widgetBack")
                .data([graphTitle])
                .join(
                    enter => {
                        var widget = enter.append("g").
                            attr("class", "widgetBack");

                        widget.append("rect")
                            .attr("class", "widgetBackground")
                            .attr("x", -Y_AXIS_LABEL_WIDTH)
                            .attr("y", TITLE_VERT_OFFSET)
                            .attr("width", width + Y_AXIS_LABEL_WIDTH)
                            .attr("height", (height + HEADER_WIDTH + X_AXIS_LABEL_HEIGHT))
                            .attr("rx", WIDGET_CORNER_RADIUS)
                            .attr("ry", WIDGET_CORNER_RADIUS)

                        widget.append("path")
                            .attr("class", "widgetHeader")
                            .attr("d", roundedRect(-Y_AXIS_LABEL_WIDTH, TITLE_VERT_OFFSET, width + Y_AXIS_LABEL_WIDTH, HEADER_WIDTH, 25, true, true, false, false))
                            .style("fill", "url(#redTitleGradient)")

                        widget.append("text")
                            .attr("class", "widgetTitle")
                            .text(d => d)
                            .attr("transform", "translate(" + ((width - Y_AXIS_LABEL_WIDTH) / 2) + "," + -25 + ")")

                    },
                    update => {
                        return update.select("text").text(d => d);
                    },
                    exit => {
                        return exit.remove();
                    })



            const titles = getTitles(content)

            //Remove special characters from Boxoffice field.
            content.forEach(c => {
                c["Boxoffice"] = c["Boxoffice"] == "" ? null : c["Boxoffice"].replace(/[^\w\s]/gi, '')
            })
            const scoreExtents = d3.extent(content, d => +d["Boxoffice"])

            var xScale = d3.scaleBand().range([0, width]).domain(titles).padding(0.4);
            var yScale = d3.scaleLog().range([0, height]).domain([scoreExtents[1], 1])

            g.select("g #bottomAxis")
                .raise()
                .attr("class", "axis")
                .attr("id", "bottomAxis")
                .attr("transform", "translate(0," + height + ")")
                .transition()
                .duration(1000)
                .call(d3.axisBottom(xScale))
                .selectAll("text")
                .attr("class", "barGraphXLabel")
                .attr("x", -15)
                .attr("y", -5)
                .style("text-anchor", "end")
                .style("font-size", "17px")
                .text(d => (d.length > 30) ? d.slice(0, 30) + "..." : d)

            g.select("g #bottomAxis").selectAll("text")
                .style("fill", "white")
                .attr("transform", "rotate(-90)")

            var yAxis = g.select("g #leftAxis")
                .raise()
                .attr("class", "axis")
                .attr("id", "leftAxis")


            yAxis.transition()
                .duration(1000)
                .call(d3.axisLeft(yScale).ticks(5))
                .selectAll("text")
                .style("fill", "white")
                .style("font-size", "14px")


            g.selectAll(".bar")
                .data(content)
                .join(
                    enter => {
                        var rect = enter.append("rect")
                            .attr("class", "bar")
                            .attr("x", d => xScale(d["Title"]))
                            .attr("y", d => height)
                            .attr("width", xScale.bandwidth())
                            .attr("height", 0)
                            .attr("fill", "url(#redGradient)")
                        rect.transition()
                            .duration(500)
                            .attr("height", d => height - yScale(+d["Boxoffice"]))
                            .attr("y", d => yScale(+d["Boxoffice"]))

                        rect
                            .on("mouseover", function (mouseInfo, data) {
                                highlightContent(data);
                                displayBubblePopup(mouseInfo, data, this)

                            })
                            .on("mouseout", (mouseInfo, data) => {
                                resetAllContent();
                                removeBubblePopup(mouseInfo);
                            })
                    },
                    update => {
                        update
                            .transition()
                            .duration(1000)
                            .attr("height", d => height - yScale(+d["Boxoffice"]))
                            .attr("y", d => yScale(+d["Boxoffice"]))

                    },
                    exit => {
                        exit.transition()
                            .remove();
                    }
                )
        }

        /**
         * Returns an array of titles contained within contentArray
         */
        function getTitles(contentArray) {

            var listOfTitles = []
            contentArray.forEach(content => {
                listOfTitles.push(content["Title"])
            })
            return listOfTitles;

        }

        /**
         * Links country paths to their associated centroid from the geographic projection. 
         */
        function mapCentroidsToData(content, mapData, path, year) {
            console.log("Doing the big filter")

            //Create country centroids
            var countryCentroids = new Map(d3.filter((mapData.features.map(d => {
                const centroid = path.centroid(d.geometry);
                const topContentForCountry = getTopContent(content, d.properties.name, 1).get(year)[0];
                return [
                    d.properties.name, {
                        centroid: { x: centroid[0], y: centroid[1] },
                        topContent: topContentForCountry
                    }]
            })), d => d[1]["topContent"] != undefined));

            console.log("Good to go")
            return countryCentroids
        }

        /**
         * Gets a number of top content for a given region. If null, it returns the global top content.
         */
        function getTopContent(contentData, region, number) {
            var yearExtents = d3.extent(contentData, d => new Date(d["Netflix Release Date"]).getFullYear())
            yearExtents[0] = 2018;
            var months = ["January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"];
            var monthName = new Intl.DateTimeFormat("en-US", { month: "long" }).format;

            var topContentPerMonth = new Map();
            for (let year = yearExtents[0]; year < yearExtents[1]; year++) {

                var filtered = (region == null) ?
                    contentData
                        .filter(d => d["Boxoffice"] != "")
                        .filter(d => new Date(d["Netflix Release Date"]).getFullYear() == year)
                    : contentData
                        .filter(d => d["Boxoffice"] != "")
                        .filter(d => new Date(d["Netflix Release Date"]).getFullYear() == year)
                        .filter(d => d["Country Availability"].includes(region))

                var top10 = filtered.sort((a, b) => d3.descending(+a["IMDb Score"], +b["IMDb Score"])).slice(0, number);

                topContentPerMonth.set(year, top10);
            }
            return topContentPerMonth;

        }

        /**
         * Converts a fiscal quarter string into a JavaScript date.
         */
        function fiscalQuarterToDate(quarter) {
            const quarterEndMonths = ["March", "June", "September", "December"];
            const month = quarterEndMonths[--quarter[1]];
            const year = quarter.substring(5, 9);

            // Sets date to 30th, while should vary between 30-31st depending on the month,
            // this doesn't add significant value.
            const date = new Date(year + " " + month + " " + 30);
            return date
        }

        /**
         * Displays the line graph for number of Netflix subscribers for each major region.
         */
        function displaySubscribersByRegion(netflixSubscribersByRegion, graphPos, width, height) {

            const numberOfHorzTicks = 5;
            const duration = 1000;

            const SPACE_BETWEEN_ROWS = 25;
            const CIRCLE_HORZ_OFFSET = 15;
            const CIRCLE_RADIUS = 8;
            const LEGEND_HORZ_OFFSET = 70;
            const LEGEND_VERT_OFFSET = 50;
            const quarterLabels = d3.filter(netflixSubscribersByRegion.columns, column => column.includes("Q"))

            var regions = new Array;

            netflixSubscribersByRegion.forEach(region => {
                regions.push(region.Area)
            })
            const lineColorScheme = d3.scaleOrdinal().domain(regions).range(d3.schemeSet1);

            //Converts data into map, where key is country, value is an array of objects containing the number of subscribers
            // across dates (set to the quarter end date)
            var processedData = new Map();
            netflixSubscribersByRegion.forEach(region => {
                var numberOfSubscribersForRegionAcrossTime = new Array;
                quarterLabels.forEach(quarter => {
                    numberOfSubscribersForRegionAcrossTime.push({
                        region: region["Area"],
                        date: fiscalQuarterToDate(quarter),
                        numberOfSubscribers: region[quarter]
                    })
                })
                processedData.set(region.Area, numberOfSubscribersForRegionAcrossTime)
            })

            var subscriberExtents = [undefined, undefined];
            quarterLabels.forEach(quarter => {
                var extentForQuarter = d3.extent(netflixSubscribersByRegion, d => +d[quarter])
                subscriberExtents[0] = d3.min([+extentForQuarter[0], +subscriberExtents[0]])
                subscriberExtents[1] = d3.max([+extentForQuarter[1], +subscriberExtents[1]])
            })

            const firstQuarterDate = fiscalQuarterToDate(quarterLabels[0]);
            const startingDate = new Date(firstQuarterDate - 1);
            const lastQuarterDate = fiscalQuarterToDate(quarterLabels[quarterLabels.length - 1]);
            var now = new Date(firstQuarterDate);

            lineGraphXScale = d3.scaleTime().range([0, width]).domain([startingDate, firstQuarterDate]).clamp(true);
            lineGraphYScale = d3.scaleLinear().range([0, height]).domain([(subscriberExtents[1] + 10000000), 0]); //Add some to the extend, so there is room for cursor

            var g = d3.select("svg").append("g")
                .attr("class", "lineGraph")
                .attr("transform", "translate(" + graphPos[0] + "," + graphPos[1] + ")")

            const TITLE_VERT_OFFSET = -50;
            const X_AXIS_LABEL_HEIGHT = 90;
            const Y_AXIS_LABEL_WIDTH = 140;
            const LEGEND_WIDTH = 350;
            var widget = g.append("g").
                attr("class", "widgetBack");

            widget.append("rect")
                .attr("class", "widgetBackground")
                .attr("x", -Y_AXIS_LABEL_WIDTH)
                .attr("y", TITLE_VERT_OFFSET)
                .attr("width", width + Y_AXIS_LABEL_WIDTH + LEGEND_WIDTH)
                .attr("height", (height + HEADER_WIDTH + X_AXIS_LABEL_HEIGHT))
                .attr("rx", WIDGET_CORNER_RADIUS)
                .attr("ry", WIDGET_CORNER_RADIUS)

            widget.append("path")
                .attr("class", "widgetHeader")
                .attr("d", roundedRect(-Y_AXIS_LABEL_WIDTH, TITLE_VERT_OFFSET, width + LEGEND_WIDTH + Y_AXIS_LABEL_WIDTH, HEADER_WIDTH, 25, true, true, false, false))
                .style("fill", "url(#redTitleGradient)")

            widget.append("text")
                .attr("class", "widgetTitle")
                .text("Netflix Subscribers Across Regions")
                .attr("transform", "translate(" + ((width - Y_AXIS_LABEL_WIDTH + LEGEND_WIDTH) / 2) + "," + -25 + ")")

            var xAxis = g.append("g")
                .attr("class", "axis")
                .attr("id", "bottomAxis")
                .attr("transform", "translate(0," + height + ")")
                .call(lineGraphXScale.axis = d3.axisBottom(lineGraphXScale).ticks(numberOfHorzTicks))
                .style("font-size", "14px")

            xAxis.append("text")
                .attr("x", (width / 2))
                .attr("y", 50)
                .attr("text-anchor", "middle")
                .text("Date")
                .style("font-size", "17px")

            var yAxis = g.append("g")
                .attr("class", "axis")
                .attr("id", "leftAxis")
                .call(d3.axisLeft(lineGraphYScale))

            yAxis.selectAll("text")
                .style("fill", "white")
                .style("font-size", "14px")

            yAxis.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -100)
                .attr("x", -(height / 2))
                .attr("text-anchor", "middle")
                .text("Number of Netflix Subscribers")
                .style("font-size", "17px")

            d3.select('defs').append('clipPath')
                .attr('id', 'clip')
                .append('rect')
                .attr('width', width)
                .attr('height', height);

            var data = processedData;

            /**
             * Create a reference free copy of data, which will be updated over time as the time x-axis moves forward.
             */
            var localData = new Map(data);
            for ([key, value] of localData) {
                var t = value.map(el => Object.assign({}, el, { numberOfSubscribers: 0 }))
                localData.set(key, t)
            }

            var paths = g.append("g")
                .attr("clip-path", "url(#clip)")
                .attr("class", "paths");

            paths.selectAll(".line")
                .data(localData.values())
                .enter()
                .append("path")
                .attr("class", "line")
                .attr("id", (d, i) => {
                    var region = d[0].region
                    return "line" + region.replace(/[^a-zA-Z0-9]/g, ''); // Remove special characters (including spaces). Not valid for HTML ID.
                })
                .attr("fill", "none")
                .attr("stroke", d => lineColorScheme(d[0]["region"])
                )
                .attr("stroke-width", 3.5)

            // Creates area gradient to be displayed underneath the lines.
            var areaGradients = d3.select("defs")
                .selectAll(".areaGradient")
                .data(localData.values())
                .join(
                    enter => {
                        var gradient = enter.append("linearGradient")
                            .attr("id", (d, i) => {
                                var region = d[0].region
                                return "gradient" + region.replace(/[^a-zA-Z0-9]/g, ''); // Remove special characters (including spaces). Not valid for HTML ID.
                            })
                            .attr("x1", "0%")
                            .attr("y1", "0%")
                            .attr("x2", "0%")
                            .attr("y2", "35%")
                            .attr("spreadMethod", "pad")
                        gradient.append("stop")
                            .attr("offset", "0%")
                            .attr("stop-color", d => lineColorScheme(d[0]["region"]))
                            .attr("stop-opacity", 0.4)
                        gradient.append("stop")
                            .attr("offset", "100%")
                            .attr("stop-color", d => lineColorScheme(d[0]["region"]))
                            .attr("stop-opacity", 0);
                    }
                )

            var areas = g.append("g")
                .attr("clip-path", "url(#clip)")
                .attr("class", "areas")

            areas.selectAll(".area")
                .data(localData.values())
                .enter()
                .append("path")
                .attr("class", "area")
                .attr("id", (d, i) => {
                    var region = d[0].region
                    return "area" + region.replace(/[^a-zA-Z0-9]/g, ''); // Remove special characters (including spaces). Not valid for HTML ID.
                })
                .attr("fill", d => {
                    var region = d[0].region
                    return "url(#gradient" + region.replace(/[^a-zA-Z0-9]/g, '') + ")"; // Remove special characters (including spaces). Not valid for HTML ID.
                })


            //Create the legend.
            var legend = g.append("g")
                .attr("class", "legend")
                .attr("transform", "translate(" + (width + LEGEND_HORZ_OFFSET) + "," + ((height / 2) - LEGEND_VERT_OFFSET) + ")");

            var legendRow = legend.selectAll(".legendRow")
                .data(data.keys())

            legendRow.enter()
                .append("g")
                .append("text")
                .attr("y", (d, i) => i * SPACE_BETWEEN_ROWS)
                .style("fill", "white")
                .style("font-size", "17px")
                .style("alignment-baseline", "central")
                .style("font-family", "Montserrat")
                .text(d => d)

            legendRow.enter()
                .append("circle")
                .attr("cx", -CIRCLE_HORZ_OFFSET)
                .attr("cy", (d, i) => i * SPACE_BETWEEN_ROWS)
                .attr("r", CIRCLE_RADIUS)
                .style("fill", d => lineColorScheme(d))

            g.append("g")
                .attr("class", "timeLine")
                .attr("clip-path", "url(#clip)")
                .attr("opacity", "0")

                .append("line")

            /**
             * Draw line cursor over mouse, and draw the estimated number of subscribers to the 
             * graph.
             */
            g.on("mousemove", (e) => {
                const x = d3.pointer(e)[0];

                g.select(".timeLine")
                    .transition()
                    .duration(250)
                    .attr("opacity", "1")

                g.select(".timeLine")
                    .select("line")
                    .attr("x1", x)
                    .attr("y1", 0)
                    .attr("x2", x)
                    .attr("y2", 300)
                    .style("stroke-dasharray", ("10, 10"))
                    .attr("stroke-width", 2)

                var xDate = lineGraphXScale.invert(x);
                var bisect = d3.bisector(function (d) { return d.date; }).left;

                var mapOfApproxValues = new Map();
                localData.forEach((d, k) => {
                    var idx = bisect(d, xDate);
                    mapOfApproxValues.set(k, d[idx])
                })

                g.select(".timeLine").selectAll("text")
                    .data(mapOfApproxValues, d => d[0])
                    .join("text")
                    .attr("x", (x < 100) ? x + 10 : x - 10)
                    .attr("y", d =>
                        lineGraphYScale(d[1].numberOfSubscribers) - 10
                    )

                    .text(d => "~" + d[1].numberOfSubscribers)
                    .attr("class", "blackBorder")
                    .style("text-anchor", (x < 100) ? "start" : "end")
                    .style("fill", "white")
                    .style("font-size", "17px")
                    .style("alignment-baseline", "central")
                    .style("font-family", "Montserrat")

            })
            /**
             * Hide the cursor.
             */
            g.on("mouseleave", () => {
                console.log("exit")
                g.select(".timeLine")
                    .transition()
                    .duration(250)
                    .attr("opacity", "0")
            })

            // Based from https://bl.ocks.org/phvaillant/ff9135e0b03d76d67c368b5c7477f402,
            // this will allow the graph time x-axis to increase with the line over time.

            var transition = d3.select({}).transition()
                .duration(duration)
                .ease(d3.easeLinear);


            var tickCounter = 0;
            (function tick() {
                transition = transition.each(function () {
                    var quarterIndex = 0;
                    data.forEach((val, key) => {

                        var newDataPoint = val.shift();
                        var now = newDataPoint.date;
                        var tempArr = localData.get(key);
                        for (var i = tickCounter; i < tempArr.length; i++) {
                            tempArr[i].numberOfSubscribers = newDataPoint.numberOfSubscribers;
                        }
                        localData.set(key, tempArr);

                        lineGraphXScale.domain([startingDate, newDataPoint.date]);

                        // Update the line
                        d3.select("#line" + key.replace(/[^a-zA-Z0-9]/g, '')) // Remove special characters (including spaces). Not valid for HTML ID.
                            .transition()
                            .duration(duration)
                            .ease(d3.easeLinear)
                            .attr('d', d3.line()
                                .curve(d3.curveBasis)
                                .x(function (d, i) {
                                    var x = lineGraphXScale(d.date);
                                    return x;
                                })
                                .y(function (d, i) {
                                    var y = lineGraphYScale(d.numberOfSubscribers);
                                    return y;
                                }))
                            .attr('transform', null);

                        // Update area below line
                        var area = d3.select("#area" + key.replace(/[^a-zA-Z0-9]/g, ''))
                        area.transition()
                            .duration(duration)
                            .ease(d3.easeLinear)
                            .attr("d", d3.area()
                                .x((d, i) => lineGraphXScale(d.date))
                                .y1(function (d, i) {
                                    var y = lineGraphYScale(d.numberOfSubscribers);
                                    return y;
                                })
                                .y0(function (d, i) {
                                    var y = height;
                                    return y;
                                }))


                    })

                    // Update the selected content's date line
                    d3.select(".selectedContentLine").select("line")
                        .transition().ease(d3.easeLinear).duration(duration)
                        .attr("x1", d => lineGraphXScale(new Date(d["Netflix Release Date"])))
                        .attr("x2", d => lineGraphXScale(new Date(d["Netflix Release Date"])))
                    d3.select(".selectedContentLine").select("text")
                        .transition().ease(d3.easeLinear).duration(duration)
                        .attr("x", d => lineGraphXScale(new Date(d["Netflix Release Date"])) + 10)

                    // Update the cursors subscriber values, so that if the user leaves the mouse on the graph,
                    // the elements update accordingly.
                    var x = d3.select(".timeLine").select("line").attr("x1");
                    var bisect = d3.bisector(function (d) { return d.date; }).left;
                    var xDate = lineGraphXScale.invert(x);

                    var mapOfApproxValues = new Map();
                    localData.forEach((d, k) => {
                        var idx = bisect(d, xDate);
                        mapOfApproxValues.set(k, d[idx])
                    })
                    g.select(".timeLine")
                        .selectAll("text")
                        .data(mapOfApproxValues, d => d[0])
                        .join("text")
                        .text(d => "~" + d[1].numberOfSubscribers)
                        .attr("y", d =>
                            lineGraphYScale(d[1].numberOfSubscribers) - 10
                        )

                    // Slide x axis to the  left
                    xAxis.transition().ease(d3.easeLinear).duration(duration).call(lineGraphXScale.axis.ticks(numberOfHorzTicks))


                    tickCounter++;

                }).transition()
                    .on('start', () => {
                        if (tickCounter < quarterLabels.length) {
                            tick()
                        }
                    })
            })();
        }

        /**
         * Draws scatter plot of IMDb ratings vs time for all elements. The scatter plot should avoid using transitions
         * as there are many points to be rendered - animated them all is too costly.
         */
        function drawScatterPlot(content, graphTitle, width, height) {

            var g = d3.select(".boxOfficeTimeScatterPlot")
            const TITLE_VERT_OFFSET = -50;
            const X_AXIS_LABEL_HEIGHT = 90;
            const Y_AXIS_LABEL_WIDTH = 70;
            const LEGEND_WIDTH = 350;
            var widget = g.append("g").
                attr("class", "widgetBack");

            widget.append("rect")
                .attr("class", "widgetBackground")
                .attr("x", -Y_AXIS_LABEL_WIDTH)
                .attr("y", TITLE_VERT_OFFSET)
                .attr("width", width + Y_AXIS_LABEL_WIDTH + LEGEND_WIDTH)
                .attr("height", (height + HEADER_WIDTH + X_AXIS_LABEL_HEIGHT))
                .attr("rx", WIDGET_CORNER_RADIUS)
                .attr("ry", WIDGET_CORNER_RADIUS)

            widget.append("path")
                .attr("class", "widgetHeader")
                .attr("d", roundedRect(-Y_AXIS_LABEL_WIDTH, TITLE_VERT_OFFSET, width + LEGEND_WIDTH + Y_AXIS_LABEL_WIDTH, HEADER_WIDTH, 25, true, true, false, false))
                .style("fill", "url(#redTitleGradient)")

            widget.append("text")
                .attr("class", "widgetTitle")
                .text(graphTitle)
                .attr("transform", "translate(" + ((width - Y_AXIS_LABEL_WIDTH + LEGEND_WIDTH) / 2) + "," + -25 + ")")

            content = d3.filter(content, d => d["IMDb Score"] != "");
            content = d3.filter(content, d => d["Genre"] != "");

            const scoreExtents = d3.extent(content, d => +d["IMDb Score"])
            const releaseDateExtents = d3.extent(content, d => new Date(d["Netflix Release Date"]));

            var xScale = d3.scaleTime().range([0, width]).domain(releaseDateExtents);
            var yScale = d3.scaleLinear().range([0, height]).domain([scoreExtents[1], 1])

            //Get genre as array.
            var contentGenres = new Array;
            content.forEach(c => {
                contentGenres.push(c["Genre"].split(', '));
                c["Genre"] = c["Genre"].split(", ");
            })

            //Convert array of arrays to single array
            const merged = [].concat.apply([], contentGenres);
            //Get unique values from merged, and remove null genre.
            const unique = Array.from(new Set(merged))
            const genreColorScheme = d3.scaleOrdinal().domain(unique).range(d3.schemeSet1)
            const SPACE_BETWEEN_ROWS = 25;
            const SPACE_BETWEEN_COLS = 150;
            const NUMBER_OF_ELEMENTS_PER_COL = 14;
            const CIRCLE_HORZ_OFFSET = 15;
            const CIRCLE_RADIUS = 8;
            const LEGEND_HORZ_OFFSET = 70;
            const LEGEND_VERT_OFFSET = 140;

            //Draw legend in row-column layout.
            var legend = g.append("g")
                .attr("class", "legend")
                .attr("transform", "translate(" + (width + LEGEND_HORZ_OFFSET) + "," + ((height / 2) - LEGEND_VERT_OFFSET) + ")");

            var legendRow = legend.selectAll(".legendRow")
                .data(unique)

            var lg = legendRow.enter()
                .append("g")
                .attr("class", "legendRow")
                .on("mouseover", (m, data) => {
                    legend.selectAll("circle,text") //highlight legend
                        .transition("legendHoverTrans")
                        .duration(250)
                        .style("fill-opacity", d => {
                            return d == data ? "1" : "0.4";
                        })
                    d3.selectAll(".scatterPlotPoint")
                        .style("fill-opacity", d => {
                            return d.Genre.indexOf(data) > -1 ? "1" : "0.2";
                        })
                        .attr("fill", d => {
                            return d.Genre.indexOf(data) > -1 ? genreColorScheme(data) : netflixColor;

                        })
                        .attr("r", d => {
                            return d.Genre.indexOf(data) > -1 ? 2 : 1;
                        })

                    drawTrendLine(content.filter(d => d.Genre.indexOf(data) > -1), g, xScale, yScale);


                }).on("mouseout", (m, data) => {
                    legend.selectAll("circle,text")
                        .transition("legendExitTrans")
                        .duration(250)
                        .style("fill-opacity", 1);

                    d3.selectAll(".scatterPlotPoint")
                        .style("fill-opacity", 1)
                        .attr("fill", netflixColor)
                        .attr("r", 1);
                    drawTrendLine(content, g, xScale, yScale);

                })


            lg.append("text")
                .attr("x", (d, i) => (i >= NUMBER_OF_ELEMENTS_PER_COL) ? SPACE_BETWEEN_COLS : 0)
                .attr("y", (d, i) => (i % NUMBER_OF_ELEMENTS_PER_COL) * SPACE_BETWEEN_ROWS)
                .style("fill", "white")
                .style("font-size", "17px")
                .style("alignment-baseline", "central")
                .style("font-family", "Montserrat")
                .text(d => d)

            lg.append("circle")
                .attr("cx", (d, i) => (i >= NUMBER_OF_ELEMENTS_PER_COL) ? SPACE_BETWEEN_COLS - CIRCLE_HORZ_OFFSET : -CIRCLE_HORZ_OFFSET)
                .attr("cy", (d, i) => (i % NUMBER_OF_ELEMENTS_PER_COL) * SPACE_BETWEEN_ROWS)
                .attr("r", CIRCLE_RADIUS)
                .style("fill", d => genreColorScheme(d))

            var xAxis = g.select("g #bottomAxis")
                .raise()
                .attr("class", "axis")
                .attr("id", "bottomAxis")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale))

            xAxis.selectAll("text")
                .attr("y", 15)
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")

            xAxis.append("text")
                .attr("x", (width / 2))
                .attr("y", 50)
                .attr("text-anchor", "middle")
                .text("Date")
                .style("font-size", "17px")

            var yAxis = g.select("g #leftAxis")
                .raise()
                .attr("class", "axis")
                .attr("id", "leftAxis")
            yAxis.call(d3.axisLeft(yScale).ticks(4))
                .selectAll("text")
                .style("fill", "white")
                .style("font-size", "14px")

            yAxis.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -40)
                .attr("x", -(height / 2))
                .attr("text-anchor", "middle")
                .text("IMDb Score")
                .style("font-size", "17px")

            g.append("g")
                .attr("class", "dots")
                .selectAll("dot")
                .data(content)
                .join("circle")
                .attr("class", "scatterPlotPoint")
                .attr("cx", d => xScale(new Date(d["Netflix Release Date"])))
                .attr("cy", d => yScale(+d["IMDb Score"]))
                .attr("r", 1)
                .attr("fill", netflixColor)


            drawTrendLine(content, g, xScale, yScale);
        }

        function drawTrendLine(content, g, xScale, yScale) {
            // Best Fit Line, based on https://stackoverflow.com/questions/57559499/plotting-a-trendline-with-d3-actual-forecast
            var regression = ss.linearRegression(content.map(d => {

                var date = +(new Date(d["Netflix Release Date"]));
                var score = +d["IMDb Score"];

                return [date, score]
            }))

            var lin = ss.linearRegressionLine(regression)
            var lindata = xScale.domain().map(x => {
                return {
                    releaseDate: (x),
                    score: lin(+x)
                }
            })
            var line = d3.line()
                .x(function (d, i) {
                    return xScale(d.releaseDate);
                })
                .y(function (d) {
                    return yScale(d.score);
                })

            var trendlines = g.selectAll(".trendline")
                .data([lindata])
                .join(
                    function (enter) {
                        return enter.append("path")
                            .attr("class", "trendline")
                            .style("stroke-dasharray", ("20, 20"))
                            .attr("stroke", "white")
                            .attr("stroke-width", 2)
                            .attr("d", line)
                    },
                    function (update) {
                        return update
                            .transition()
                            .duration(1000)
                            .attr("d", line)
                    },
                    function (exit) {
                        return exit.remove();
                    }

                );
        }

        Promise.all([
            d3.csv("data/NetflixSubscribersbyCountryfrom2018toQ2_2020.csv"),
            d3.csv("data/NetflixSubscribersbyCountry.csv"),
            d3.csv("data/netflix-rotten-tomatoes-metacritic-imdb.csv"),
            //d3.csv("data/movie_metadata.csv"),
            d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson"),
        ]).then(function (files) {
            const netflixSubscribersByCountry = files[1]
            const netflixSubscribersByRegion = files[0]
            const netflixShows = files[2]
            //const movieData = files[2]
            const mapData = files[3]

            // Append SVG Object to the page
            d3.select("body")
                .append("svg")
                .attr('width', 2200)
                .attr('height', 2000)
            createDefs();
            linkCountryNaming(mapData, netflixSubscribersByCountry)
            var path = displayMap(mapData, netflixSubscribersByCountry)
            const barGraphSize = [590, 300];
            const graphPos = [935, 50];
            const boxOfficeSuccessGraphPos = [1610, 50];
            const lineGraphPos = [140, 700];
            const lineGraphSize = [680, 300];
            const scatterPlotPos = [1250, 700];
            const scatterPlotSize = [600, 300];
            const periodBetweenGraphs = 1000;

            initGraph(graphPos, "topContentBarGraph")
            initGraph(boxOfficeSuccessGraphPos, "boxOfficeSucessGraph")
            initGraph(scatterPlotPos, "boxOfficeTimeScatterPlot")
            var topContent = getTopContent(netflixShows, null, 10);

            const boxOfficeExtents = d3.extent(netflixShows, d => +d["Boxoffice"].replace(/[^\w\s]/gi, ''))
            var delay = 0;
            const delayBetweenYearDisplay = 5000;

            var blob = new Blob([
                document.querySelector('#worker').textContent
            ], { type: "text/javascript" })

            const worker = new Worker(window.URL.createObjectURL(blob));;
            var firstPass = true;
            topContent.forEach((content, year) => {
                setTimeout(function () {
                    worker.postMessage(({ content: netflixShows, mapData: mapData, path: JSONfn.stringify(path), year: year }))

                    worker.onmessage = function (msg) {
                        if (firstPass) {
                            displaySubscribersByRegion(netflixSubscribersByRegion, lineGraphPos, lineGraphSize[0], lineGraphSize[1])
                            drawScatterPlot(netflixShows, "Content released on Netflix over time", scatterPlotSize[0], scatterPlotSize[1])

                            firstPass = false
                        }
                        displayTopContentBubbles(msg.data, netflixShows, mapData, path, year, boxOfficeExtents)
                        drawHighestRatedGraph(content, "Highest Rated Content On Netflix During " + year, barGraphSize[0], barGraphSize[1])
                        drawBoxOfficeSuccessGraph(content, "Box Office Of Top Content On Netflix During " + year, barGraphSize[0], barGraphSize[1])
                    }
                }, delay);
                delay += delayBetweenYearDisplay
            })

        }).catch(function (err) {
            console.log(err)
            // handle error here
        })

    </script>
</body>

</html>