<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Lab 4 - Netflix Visualisations</title>
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,500,800" rel="stylesheet">

    <style>
        body {
            background-color: #232323;
        }

        .axis path,
        line {
            stroke: white !important;
        }

        .axis text {
            fill: white !important
        }

        .widgetBackground {
            fill: #151515;
        }

        .widgetTitle {
            font-family: Montserrat;
            text-anchor: middle;
            font-size: 25px;
            fill: #151515;
        }

        .blackBorder {
            text-shadow: -1px 1px 0 #000,
                1px 1px 0 #000,
                1px -1px 0 #000,
                -1px -1px 0 #000;

        }
    </style>
</head>

<body>
    <script src='https://d3js.org/d3.v7.js'></script>
    <script src='https://unpkg.com/simple-statistics@7.7.5/dist/simple-statistics.min.js'></script>

    <script>
        const widgetBackgroundColor = "#151515";

        const defaultMapColor = "#373737"
        const netflixColor = "#E50914"
        const netflixColorDarker = "#6e1115"
        const netflixColorDarkerLight = "#a0060e"
        const white = "#F5F5F1"
        const whiteDarker = "#c4c4c0"

        const grey = "#4e4b4b"
        const darkGrey = "#221F1F"
        const HEADER_WIDTH = 35
        const WIDGET_CORNER_RADIUS = 25;

        var lineGraphXScale;
        var lineGraphYScale;

        function subscriberArrayToMap(netflixSubscribersByCountry) {
            var map = (d3.group(netflixSubscribersByCountry, d => d.Country));
            map.forEach((element, key) => {
                map.set(key, element[0])
            })

            return map

        }

        function linkCountryNaming(mapData, netflixSubscribersByCountry) {

            mapData.features.forEach(element => {
                element.properties.name = element.properties.name.trim()
            })

            netflixSubscribersByCountry.forEach(element => {
                element.Country = element.Country.trim()
            })
            mapData.features.forEach(element => {
                switch (element.properties.name) {
                    case "USA":
                        element.properties.name = "United States"
                        break;
                    case "England":
                        element.properties.name = "United Kingdom"
                        break;
                    case "Slovakia":
                        element.properties.name = "Slovak Republic"
                        break;
                    default:
                        break;
                }
            });

            // const netflixSubMap = subscriberArrayToMap(netflixSubscribersByCountry)
            // netflixSubMap.forEach((element, key) => {

            //     const indexOfMapContainingCountry = mapData.features.map(function (e) {
            //         return e.properties.name
            //     }).indexOf(key)

            //     if (indexOfMapContainingCountry > 0) {

            //     } else {
            //         console.log("not found `" + key + "`")
            //     }


            // })
        }

        function displayMap(mapData, subscriberData) {
            const X_SIZE = 850;
            const Y_SIZE = 600;
            const X_MARGIN = 50;
            const Y_MARGIN = 50;

            const X_MAX = X_SIZE - (X_MARGIN * 2);
            const Y_MAX = Y_SIZE - (Y_MARGIN * 2);
            const MAP_VERT_OFFSET = 30;
            const TITLE_VERT_OFFSET = 25;
            const projection = d3.geoMercator()
                .scale(160)
                .center([0, 60])
                .translate([X_MAX / 2, 200]);
            const path = d3.geoPath(projection);

            var g = d3.select("svg").append("g")
                .attr("class", "subscriberMap")


            g.append("rect")
                .attr("class", "widgetBackground")
                .attr("width", X_SIZE)
                .attr("height", (Y_SIZE + HEADER_WIDTH))
                .attr("rx", WIDGET_CORNER_RADIUS)
                .attr("ry", WIDGET_CORNER_RADIUS)

            g.append("path")
                .attr("class", "widgetHeader")
                .attr("d", roundedRect(0, 0, X_SIZE, HEADER_WIDTH, 25, true, true, false, false))
                .style("fill", "url(#redTitleGradient)")

            g.append("text")
                .attr("class", "widgetTitle")
                .text("Netflix Total Subscribers & Top Available Content Per Region")
                .attr("transform", "translate(" + (X_SIZE / 2) + "," + TITLE_VERT_OFFSET + ")")

            var innerSvg = d3.select(".subscriberMap")
                .append("svg")
                .attr("y", HEADER_WIDTH)
                .attr("width", X_SIZE)
                .attr("height", Y_SIZE)
                .attr("class", "map")


            var paths = innerSvg.selectAll("path")
                .data(mapData.features)
                .enter()
                .append("path")
                .attr("class", "country")
                .attr("id", (d) => d.properties.name)
                .attr("d", (d) => path(d))
                .attr("fill", defaultMapColor)
                .style("stroke", "black")
                .style("stroke-width", 0);


            const extents = getSubscriberExtentsAcrossQuarters(subscriberData);
            const delayBetweenColourShifts = 1000;
            const durationOfColourShifts = 1000;
            const quarters = subscriberData.columns.filter(column => column.includes("# of Subscribers"))


            const colourScale = d3.scaleLinear()
                .domain(extents)
                .range([defaultMapColor, netflixColor])

            paths.transition()
                .delay(delayBetweenColourShifts)
                .duration(durationOfColourShifts)
                .attr("fill", (d) => setCountryColour(d,
                    subscriberData,
                    colourScale,
                    "# of Subscribers Q1 2021"))

                //     .transition()
                // .delay(delayBetweenColourShifts)
                // .duration(durationOfColourShifts)
                // .attr("fill", "green")

                .transition()
                .delay(delayBetweenColourShifts)
                .duration(durationOfColourShifts)
                .attr("fill", (d) => {


                    const col = setCountryColour(d,
                        subscriberData,
                        colourScale,
                        "# of Subscribers Q4 2021 (Estimate)")
                    return col;

                })
            return path;
        }

        function getSubscriberExtentsAcrossQuarters(subscriberData) {

            const quarters = subscriberData.columns.filter(column => column.includes("# of Subscribers"))

            var subscriberExtents = [];
            quarters.forEach(quarter => {
                const quarterExtents = d3.extent(subscriberData, (d) => {
                    return +d[quarter]
                })

                subscriberExtents =
                    [d3.min([subscriberExtents[0], quarterExtents[0]]),
                    d3.max([subscriberExtents[1], quarterExtents[1]])]

            })
            return subscriberExtents

        }

        function setCountryColour(country, subscriberData, colourScale, field) {


            const subscriberDataForCountry = subscriberData.filter(data => {
                return country.properties.name === data.Country
            });

            if (subscriberDataForCountry.length != 0) {
                const numberOfSubscribers = +subscriberDataForCountry[0][field]

                return colourScale(numberOfSubscribers)

            } else {
                return defaultMapColor
            }
        }

        function displayTopContentBubbles(countryCentroids, content, mapData, path, year, boxOfficeExtents) {


            const maxRadius = 40;


            // Get extents (upper-lower limits) of total cases.
            // var extent = d3.extent(countryCentroids.values(), d => +d["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, ''))
            // Create radius scale.
            var radiusScale = d3.scaleLog()
                .domain([1, boxOfficeExtents[1]])
                .range([0, maxRadius])
                .clamp(true)



            var bubbles = d3.select("svg")
                .selectAll(".bubble")
                .data(countryCentroids, d => {
                    return d[0]
                })
                .join(
                    enter => {

                        var g = enter.append("g").attr("class", "bubble")
                            .on("mouseover", function (e, d) {
                                displayBubblePopup(e, d, this)
                                highlightContent(d[1].topContent)
                            })
                            .on("mouseout", function (e, d) {
                                removeBubblePopup();
                                resetAllContent();

                            })
                        g.append("circle")
                            .attr("cx", d => {
                                return (d[1].centroid.x + radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))
                            })
                            .attr("cy", d => {
                                return (d[1].centroid.y + radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))
                            })
                            .attr("r", d => {
                                var boxoffice = +d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '');
                                var radius = radiusScale(boxoffice);
                                return radius
                            })
                            .attr("fill", "none")
                            .attr("stroke", "black")
                            .attr('pointer-events', 'none')

                        g.append("clipPath")
                            .attr("id", d => "bubblePath" + d[0].split(" ").join(""))
                            .append("circle")
                            .attr("cx", d => {
                                return (d[1].centroid.x + radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))
                            })
                            .attr("cy", d => {
                                return (d[1].centroid.y + radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))
                            })
                            .attr("r", d => {
                                var boxoffice = +d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '');
                                var radius = radiusScale(boxoffice);
                                return radius
                            })
                            .attr('pointer-events', 'none')

                        g.append("image")
                            .attr("x", d => {
                                return (d[1].centroid.x)
                            })
                            .attr("y", d => {
                                return d[1].centroid.y
                            })
                            .attr("clip-path", d => "url(#bubblePath" + d[0].split(" ").join("") + ")")

                            .attr("width", (maxRadius * 2))
                            .attr('xlink:href', d => d[1]["topContent"]["Image"])
                            .style("opacity", 0.7)


                    },
                    update => {
                        update.select("clipPath").select("circle")
                            .transition()
                            .duration(500)
                            .attr("r", d => radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))
                        update.select("circle")
                            .transition()
                            .duration(500)
                            .attr("r", d => radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))

                        update
                            .select("image")
                            .attr('xlink:href', d => d[1]["topContent"]["Image"])
                    },
                    exit => {
                        return exit.remove();
                    })


        }



        function displayBubblePopup(e, d, thisElement = this) {
            const popupWidth = 460, popupHeight = 270;
            const titleBarHeight = 30;
            const horzOffset = 100, vertOffset = -60;
            const titleOffset = 13;
            const infoOffset = 42;
            const newLineOffset = 22;

            const titleTextDelay = 50;
            const infoTextDelay = 350;
            const textDuration = 250;
            const bubbleDuration = 350;
            const mainBubbleDelay = 200;

            const titleFontSize = "20px";
            const infoFontSize = "17px";
            const elementClass = d3.select(thisElement).attr("class");

            const bubbleCentroid = { x: d3.pointer(e, d3.select("svg"))[0], y: d3.pointer(e, d3.select("svg"))[1] } //need to pass svg as target to mouse event due to transformed rects.
            var movieData = (elementClass == "bubble") ? d[1].topContent : d;
            var g = d3.select("svg")
                .append("g")
                .raise()
                .attr("class", "bubblePopup")
                // If cursor is on far right of page, move to left of cursor. Else move to right.
                .attr("transform", "translate(" + ((bubbleCentroid.x > 1600) ? bubbleCentroid.x - popupWidth - horzOffset : bubbleCentroid.x + horzOffset)
                    + "," + (bubbleCentroid.y + vertOffset) + ")")

            g.append("path")
                .attr("d", roundedRect(0, titleBarHeight, popupWidth, 0, 6, false, false, true, true))
                .transition()
                .delay(mainBubbleDelay)
                .duration(bubbleDuration)
                .attr("d", roundedRect(0, titleBarHeight, popupWidth, popupHeight, 6, false, false, true, true))
                .style("fill", "url(#whiteGradient)")


            g.append("path")
                .attr("d", roundedRect(0, 0, popupWidth, 0, 6, true, true, false, false))
                .transition()
                .duration(bubbleDuration)
                .attr("d", roundedRect(0, 0, popupWidth, titleBarHeight, 6, true, true, false, false))
                .style("fill", "url(#redTitleGradient)")

            g.append("text")
                .attr("class", "popupTitle")
                .attr("x", (popupWidth / 2))
                .attr("y", titleOffset)
                .style("fill", "white")
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text(movieData["Title"])
                .transition()
                .duration(textDuration)
                .delay(titleTextDelay)
                .style("font-size", titleFontSize)


            var info = g.append("g")
                .attr("class", "popupInformation")
                .attr("transform", "translate(" + (0) + "," + (infoOffset) + ")")

            info.append("text")
                .attr("x", (popupWidth / 2))
                .attr("y", 0)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text("Directed by:")
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)


            info.append("text")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .style("font-weight", "bold")
                .text(movieData["Director"])
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset * 2)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text("Genre(s):")
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset * 3)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .style("font-weight", "bold")
                .text(movieData["Genre"])
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset * 4)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text("Release Date (Initial / Netflix):")
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset * 5)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .style("font-weight", "bold")
                .text(new Date(movieData["Release Date"]).toISOString().split('T')[0] + " / " + new Date(movieData["Netflix Release Date"]).toISOString().split('T')[0])
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset * 6)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text("IMDb Score:")
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset * 7)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .style("font-weight", "bold")
                .text(+movieData["IMDb Score"])
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset * 8)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text("Box office revenue:")
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset * 9)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .style("font-weight", "bold")
                .text("$" + movieData["Boxoffice"])
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset * 10)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text("Awards received:")
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)

            info.append("text")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset * 11)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .style("font-weight", "bold")
                .text(Math.trunc(+movieData["Awards Received"]))
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", infoFontSize)


        }

        // Taken from https://stackoverflow.com/questions/12115691/svg-d3-js-rounded-corners-on-one-side-of-a-rectangle
        function roundedRect(x, y, w, h, r, tl, tr, bl, br) {
            var retval;
            retval = "M" + (x + r) + "," + y;
            retval += "h" + (w - 2 * r);
            if (tr) { retval += "a" + r + "," + r + " 0 0 1 " + r + "," + r; }
            else { retval += "h" + r; retval += "v" + r; }
            retval += "v" + (h - 2 * r);
            if (br) { retval += "a" + r + "," + r + " 0 0 1 " + -r + "," + r; }
            else { retval += "v" + r; retval += "h" + -r; }
            retval += "h" + (2 * r - w);
            if (bl) { retval += "a" + r + "," + r + " 0 0 1 " + -r + "," + -r; }
            else { retval += "h" + -r; retval += "v" + -r; }
            retval += "v" + (2 * r - h);
            if (tl) { retval += "a" + r + "," + r + " 0 0 1 " + r + "," + -r; }
            else { retval += "v" + -r; retval += "h" + r; }
            retval += "z";
            return retval;
        }
        function removeBubblePopup() {
            d3.selectAll(".bubblePopup")
                .transition()
                .duration(150)
                .style("opacity", 0)
                .remove();

        }

        function createDefs() {
            var redGradient = d3.select("svg").append("defs")
                .append("linearGradient")
                .attr("id", "redGradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%")
                .attr("spreadMethod", "pad");
            redGradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", netflixColor)
                .attr("stop-opacity", 1);
            redGradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", netflixColorDarker)
                .attr("stop-opacity", 1);

            var redTitleGradient = d3.select("svg").append("defs")
                .append("linearGradient")
                .attr("id", "redTitleGradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%")
                .attr("spreadMethod", "pad");
            redTitleGradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", netflixColor)
                .attr("stop-opacity", 1);
            redTitleGradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", netflixColorDarkerLight)
                .attr("stop-opacity", 1);

            var whiteGradient = d3.select("defs")
                .append("linearGradient")
                .attr("id", "whiteGradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%")
                .attr("spreadMethod", "pad");
            whiteGradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", white)
                .attr("stop-opacity", 1);
            whiteGradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", whiteDarker)
                .attr("stop-opacity", 1);


            var greyGradient = d3.select("defs")
                .append("linearGradient")
                .attr("id", "greyGradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%")
                .attr("spreadMethod", "pad");
            greyGradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", grey)
                .attr("stop-opacity", 1);
            greyGradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", darkGrey)
                .attr("stop-opacity", 1);

            var blur = d3.select("defs")
                .append("filter")
                .attr("id", "blur")
                .append("feGaussianBlur")
                .attr("stdDeviation", 1.5);


        }
        function initGraph(graphPos, graphClass) {

            var g = d3.select("svg").append("g")
                .attr("class", graphClass)
                .attr("transform", "translate(" + graphPos[0] + "," + graphPos[1] + ")")

            g.append("g").attr("id", "bottomAxis")
            g.append("g").attr("id", "leftAxis")


        }

        function drawHighestRatedGraph(content, graphTitle, width, height) {
            const TITLE_VERT_OFFSET = -50;
            const X_AXIS_LABEL_HEIGHT = 300;
            const Y_AXIS_LABEL_WIDTH = 70;
            var g = d3.select(".topContentBarGraph")
            g.selectAll(".widgetBack")
                .data([graphTitle])
                .join(
                    enter => {
                        var widget = enter.append("g").
                            attr("class", "widgetBack");

                        widget.append("rect")
                            .attr("class", "widgetBackground")
                            .attr("x", -Y_AXIS_LABEL_WIDTH)
                            .attr("y", TITLE_VERT_OFFSET)
                            .attr("width", width + Y_AXIS_LABEL_WIDTH)
                            .attr("height", (height + HEADER_WIDTH + X_AXIS_LABEL_HEIGHT))
                            .attr("rx", WIDGET_CORNER_RADIUS)
                            .attr("ry", WIDGET_CORNER_RADIUS)

                        widget.append("path")
                            .attr("class", "widgetHeader")
                            .attr("d", roundedRect(-Y_AXIS_LABEL_WIDTH, TITLE_VERT_OFFSET, width + Y_AXIS_LABEL_WIDTH, HEADER_WIDTH, 25, true, true, false, false))
                            .style("fill", "url(#redTitleGradient)")

                        widget.append("text")
                            .attr("class", "widgetTitle")
                            .text(d => d)
                            .attr("transform", "translate(" + ((width - Y_AXIS_LABEL_WIDTH) / 2) + "," + -25 + ")")


                    },
                    update => {
                        return update.select("text").text(d => d);
                    },
                    exit => {
                        return exit.remove();
                    })


            const titles = getTitles(content)

            const scoreExtents = d3.extent(content, d => +d["IMDb Score"])

            var xScale = d3.scaleBand().range([0, width]).domain(titles).padding(0.4);
            var yScale = d3.scaleLinear().range([0, height]).domain([scoreExtents[1], scoreExtents[0] - 0.1])

            g.select("g #bottomAxis")
                .raise()
                .attr("class", "axis")
                .attr("id", "bottomAxis")
                .attr("transform", "translate(0," + height + ")")
                .transition("something else")
                .duration(1000)
                .call(d3.axisBottom(xScale))
                .selectAll("text")
                .attr("class", "barGraphXLabel")
                .attr("x", -15)
                .attr("y", -5)
                .style("text-anchor", "end")
                .style("font-size", "17px")
                .text(d => (d.length > 30) ? d.slice(0, 30) + "..." : d)

            g.select("g #bottomAxis").selectAll("text")
                .style("fill", "white")
                .attr("transform", "rotate(-90)")

            var yAxis = g.select("g #leftAxis")
                .raise()
                .attr("class", "axis")
                .attr("id", "leftAxis")
            yAxis.transition()
                .duration(1000)
                .call(d3.axisLeft(yScale).ticks(5))
                .selectAll("text")
                .style("fill", "white")
                .style("font-size", "14px")

            g.selectAll(".bar")

                .data(content)
                .join(
                    enter => {
                        var rect = enter.append("rect")
                            .attr("class", "bar")
                            .attr("x", d => xScale(d["Title"]))
                            .attr("y", d => height)
                            .attr("width", xScale.bandwidth())
                            .attr("height", 10)
                            .attr("fill", "url(#redGradient)")

                        rect.transition()
                            .duration(500)
                            .attr("height", d => height - yScale(+d["IMDb Score"]))
                            .attr("y", d => yScale(+d["IMDb Score"]))

                        rect
                            .on("mouseover", function (mouseInfo, data) {
                                highlightContent(data);
                                displayBubblePopup(mouseInfo, data, this)

                            })
                            .on("mouseout", (mouseInfo, data) => {
                                resetAllContent();
                                removeBubblePopup(mouseInfo);
                            })


                    },
                    update => {
                        update
                            .transition()
                            .duration(1000)
                            .attr("height", d => height - yScale(+d["IMDb Score"]))
                            .attr("y", d => yScale(+d["IMDb Score"]))

                    },
                    exit => {
                        exit.transition()
                            .remove();
                    }
                )
        }

        function highlightContent(content) {
            d3.selectAll(".bar")
                .transition()
                .duration(250)
                .style("fill-opacity", d => {
                    return d.Title == content.Title ? "1" : "0.4";
                })
            d3.selectAll(".barGraphXLabel")
                .transition()
                .duration(250)
                .style("fill-opacity", d => {
                    return d == content.Title ? "1" : "0.4";
                })

            d3.selectAll(".scatterPlotPoint")
                .style("fill-opacity", d => {
                    return d.Title == content.Title ? "1" : "0.2";
                })
                .attr("r", d => {
                    return d.Title == content.Title ? 8 : 1;
                })

            highlightBubbles(content.Title);
            drawContentReleaseLine(content)
        }

        function drawContentReleaseLine(content) {
            var g = d3.select(".lineGraph")
                .append("g")
                .attr("class", "selectedContentLine")
                .data([content])

            g.append("line")
                .attr("x1", lineGraphXScale(new Date(content["Netflix Release Date"])))
                .attr("y1", 0)
                .attr("x2", lineGraphXScale(new Date(content["Netflix Release Date"])))
                .attr("y2", 300)
                .style("stroke-dasharray", ("10, 10"))
                .attr("stroke-width", 2)

            g.append("text")
                .text(d => content.Title)
                .attr("x", lineGraphXScale(new Date(content["Netflix Release Date"])) + 10)
                .attr("class", "blackBorder")
                .style("fill", "white")
                .style("font-size", "17px")
                .style("alignment-baseline", "central")
                .style("font-family", "Montserrat")

        }

        function resetAllContent() {
            d3.selectAll(".bar")
                .transition()
                .duration(250)
                .style("fill-opacity", 1);

            d3.selectAll(".barGraphXLabel")
                .transition()
                .duration(250)
                .style("fill-opacity", 1)
            d3.selectAll(".scatterPlotPoint")
                .style("fill-opacity", 1)
                .attr("fill", netflixColor)
                .attr("r", 1);

            resetBubbles();

            d3.selectAll(".selectedContentLine").transition().duration(500).style("opacity", 0).remove();

        }

        function highlightBubbles(title) {
            d3.selectAll(".bubble")
                .transition()
                .duration(250)
                .attr("opacity", d => {
                    return d[1].topContent.Title == title ? 1 : 0.6;
                })
                .select("circle")
                .attr("stroke", d => {
                    return d[1].topContent.Title == title ? "url(#redGradient)" : "black";
                })
                .attr("stroke-width", d => {
                    return d[1].topContent.Title == title ? "8px" : "1px";

                })

            d3.selectAll(".bubble")
                .selectAll("image")
                .transition()
                .duration(250)
                .style("opacity", d => {
                    return d[1].topContent.Title == title ? 1 : 0.7;
                })
                .attr("filter", d => {
                    return d[1].topContent.Title == title ? null : "url(#blur)";
                })

        }

        function resetBubbles() {
            d3.selectAll(".bubble")
                .transition()
                .duration(500)
                .attr("opacity", 1)
                .select("circle")
                .attr("stroke", "black")
                .attr("stroke-width", "1px")

            d3.selectAll(".bubble")
                .selectAll("image")
                .transition()
                .duration(500)
                .style("opacity", 0.7)
                .attr("filter", null)
        }

        function drawBoxOfficeSuccessGraph(content, graphTitle, width, height) {

            const TITLE_VERT_OFFSET = -50;
            const X_AXIS_LABEL_HEIGHT = 300;
            const Y_AXIS_LABEL_WIDTH = 70;
            var g = d3.select(".boxOfficeSucessGraph")
            g.selectAll(".widgetBack")
                .data([graphTitle])
                .join(
                    enter => {
                        var widget = enter.append("g").
                            attr("class", "widgetBack");

                        widget.append("rect")
                            .attr("class", "widgetBackground")
                            .attr("x", -Y_AXIS_LABEL_WIDTH)
                            .attr("y", TITLE_VERT_OFFSET)
                            .attr("width", width + Y_AXIS_LABEL_WIDTH)
                            .attr("height", (height + HEADER_WIDTH + X_AXIS_LABEL_HEIGHT))
                            .attr("rx", WIDGET_CORNER_RADIUS)
                            .attr("ry", WIDGET_CORNER_RADIUS)

                        widget.append("path")
                            .attr("class", "widgetHeader")
                            .attr("d", roundedRect(-Y_AXIS_LABEL_WIDTH, TITLE_VERT_OFFSET, width + Y_AXIS_LABEL_WIDTH, HEADER_WIDTH, 25, true, true, false, false))
                            .style("fill", "url(#redTitleGradient)")

                        widget.append("text")
                            .attr("class", "widgetTitle")
                            .text(d => d)
                            .attr("transform", "translate(" + ((width - Y_AXIS_LABEL_WIDTH) / 2) + "," + -25 + ")")

                    },
                    update => {
                        return update.select("text").text(d => d);
                    },
                    exit => {
                        return exit.remove();
                    })



            const titles = getTitles(content)

            //Remove special characters from Boxoffice field.
            content.forEach(c => {
                c["Boxoffice"] = c["Boxoffice"] == "" ? null : c["Boxoffice"].replace(/[^\w\s]/gi, '')
            })
            const scoreExtents = d3.extent(content, d => +d["Boxoffice"])

            var xScale = d3.scaleBand().range([0, width]).domain(titles).padding(0.4);
            var yScale = d3.scaleLog().range([0, height]).domain([scoreExtents[1], 1])

            g.select("g #bottomAxis")
                .raise()
                .attr("class", "axis")
                .attr("id", "bottomAxis")
                .attr("transform", "translate(0," + height + ")")
                .transition("something else")
                .duration(1000)
                .call(d3.axisBottom(xScale))
                .selectAll("text")
                .attr("class", "barGraphXLabel")
                .attr("x", -15)
                .attr("y", -5)
                .style("text-anchor", "end")
                .style("font-size", "17px")
                .text(d => (d.length > 30) ? d.slice(0, 30) + "..." : d)

            g.select("g #bottomAxis").selectAll("text")
                .style("fill", "white")
                .attr("transform", "rotate(-90)")

            var yAxis = g.select("g #leftAxis")
                .raise()
                .attr("class", "axis")
                .attr("id", "leftAxis")


            yAxis.transition()
                .duration(1000)
                .call(d3.axisLeft(yScale).ticks(5))
                .selectAll("text")
                .style("fill", "white")
                .style("font-size", "14px")


            g.selectAll(".bar")
                .data(content)
                .join(
                    enter => {
                        var rect = enter.append("rect")
                            .attr("class", "bar")
                            .attr("x", d => xScale(d["Title"]))
                            .attr("y", d => height)
                            .attr("width", xScale.bandwidth())
                            .attr("height", 0)
                            .attr("fill", "url(#redGradient)")
                        rect.transition()
                            .duration(500)
                            .attr("height", d => height - yScale(+d["Boxoffice"]))
                            .attr("y", d => yScale(+d["Boxoffice"]))

                        rect
                            .on("mouseover", function (mouseInfo, data) {
                                highlightContent(data);
                                displayBubblePopup(mouseInfo, data, this)

                            })
                            .on("mouseout", (mouseInfo, data) => {
                                resetAllContent();
                                removeBubblePopup(mouseInfo);
                            })
                    },
                    update => {
                        update
                            .transition()
                            .duration(1000)
                            .attr("height", d => height - yScale(+d["Boxoffice"]))
                            .attr("y", d => yScale(+d["Boxoffice"]))

                    },
                    exit => {
                        exit.transition()
                            .remove();
                    }
                )
        }
        function getTitles(contentArray) {

            var listOfTitles = []
            contentArray.forEach(content => {
                listOfTitles.push(content["Title"])
            })
            return listOfTitles;

        }

        function mapCentroidsToData(content, mapData, path, year) {
            console.log("Doing the big filter")

            //Create country centroids
            var countryCentroids = new Map(d3.filter((mapData.features.map(d => {
                const centroid = path.centroid(d.geometry);
                const topContentForCountry = getTopContent(content, d.properties.name, 1).get(year)[0];
                return [
                    d.properties.name, {
                        centroid: { x: centroid[0], y: centroid[1] },
                        topContent: topContentForCountry
                    }]
            })), d => d[1]["topContent"] != undefined));

            console.log("Good to go")
            return countryCentroids
        }

        function getCountryCentroidsWithTopContentEachYear(topContent, netflixShows, mapData, path) {
            var centroidDataForEachYear = new Map();
            // topContent.forEach((_, year) => {
            //     centroidDataForEachYear.set(year, mapCentroidsToData(netflixShows, mapData, path, year))
            // })

            centroidDataForEachYear.set(2015, mapCentroidsToData(netflixShows, mapData, path, 2015))
            centroidDataForEachYear.set(2016, mapCentroidsToData(netflixShows, mapData, path, 2016))

            return centroidDataForEachYear;
        }
        function getTopContent(contentData, region, number) {
            var yearExtents = d3.extent(contentData, d => new Date(d["Netflix Release Date"]).getFullYear())
            var months = ["January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"];
            var monthName = new Intl.DateTimeFormat("en-US", { month: "long" }).format;

            var topContentPerMonth = new Map();
            for (let year = yearExtents[0]; year < yearExtents[1]; year++) {

                var filtered = (region == null) ?
                    contentData
                        .filter(d => d["Boxoffice"] != "")
                        .filter(d => new Date(d["Netflix Release Date"]).getFullYear() == year)
                    : contentData
                        .filter(d => d["Boxoffice"] != "")
                        .filter(d => new Date(d["Netflix Release Date"]).getFullYear() == year)
                        .filter(d => d["Country Availability"].includes(region))

                var top10 = filtered.sort((a, b) => d3.descending(+a["IMDb Score"], +b["IMDb Score"])).slice(0, number);

                topContentPerMonth.set(year, top10);
            }
            return topContentPerMonth;

        }


        function fiscalQuarterToDate(quarter) {
            const quarterEndMonths = ["March", "June", "September", "December"];
            const month = quarterEndMonths[--quarter[1]];
            const year = quarter.substring(5, 9);

            // Sets date to 30th, while should vary between 30-31st depending on the month,
            // this doesn't add significant value.
            const date = new Date(year + " " + month + " " + 30);
            return date
        }


        function displaySubscribersByRegion(netflixSubscribersByRegion, graphPos, width, height) {

            const numberOfHorzTicks = 5;
            const duration = 1000;

            const SPACE_BETWEEN_ROWS = 25;
            const CIRCLE_HORZ_OFFSET = 15;
            const CIRCLE_RADIUS = 8;
            const LEGEND_HORZ_OFFSET = 70;
            const LEGEND_VERT_OFFSET = 50;
            const quarterLabels = d3.filter(netflixSubscribersByRegion.columns, column => column.includes("Q"))

            var regions = new Array;

            netflixSubscribersByRegion.forEach(region => {
                regions.push(region.Area)
            })
            const lineColorScheme = d3.scaleOrdinal().domain(regions).range(d3.schemeSet1);

            //Converts data into map, where key is country, value is an array of objects containing the number of subscribers
            // across dates (set to the quarter end date)
            var processedData = new Map();
            netflixSubscribersByRegion.forEach(region => {
                var numberOfSubscribersForRegionAcrossTime = new Array;
                quarterLabels.forEach(quarter => {
                    numberOfSubscribersForRegionAcrossTime.push({
                        region: region["Area"],
                        date: fiscalQuarterToDate(quarter),
                        numberOfSubscribers: region[quarter]
                    })
                })
                processedData.set(region.Area, numberOfSubscribersForRegionAcrossTime)
            })

            var subscriberExtents = [undefined, undefined];
            quarterLabels.forEach(quarter => {
                var extentForQuarter = d3.extent(netflixSubscribersByRegion, d => +d[quarter])
                subscriberExtents[0] = d3.min([+extentForQuarter[0], +subscriberExtents[0]])
                subscriberExtents[1] = d3.max([+extentForQuarter[1], +subscriberExtents[1]])
            })

            const firstQuarterDate = fiscalQuarterToDate(quarterLabels[0]);
            const startingDate = new Date(firstQuarterDate.getFullYear(), 0, 1);
            const lastQuarterDate = fiscalQuarterToDate(quarterLabels[quarterLabels.length - 1]);
            var now = new Date(firstQuarterDate);

            lineGraphXScale = d3.scaleTime().range([0, width]).domain([startingDate, firstQuarterDate])
            lineGraphYScale = d3.scaleLinear().range([0, height]).domain([subscriberExtents[1], 0]);

            var g = d3.select("svg").append("g")
                .attr("class", "lineGraph")
                .attr("transform", "translate(" + graphPos[0] + "," + graphPos[1] + ")")

            const TITLE_VERT_OFFSET = -50;
            const X_AXIS_LABEL_HEIGHT = 90;
            const Y_AXIS_LABEL_WIDTH = 140;
            const LEGEND_WIDTH = 350;
            var widget = g.append("g").
                attr("class", "widgetBack");

            widget.append("rect")
                .attr("class", "widgetBackground")
                .attr("x", -Y_AXIS_LABEL_WIDTH)
                .attr("y", TITLE_VERT_OFFSET)
                .attr("width", width + Y_AXIS_LABEL_WIDTH + LEGEND_WIDTH)
                .attr("height", (height + HEADER_WIDTH + X_AXIS_LABEL_HEIGHT))
                .attr("rx", WIDGET_CORNER_RADIUS)
                .attr("ry", WIDGET_CORNER_RADIUS)

            widget.append("path")
                .attr("class", "widgetHeader")
                .attr("d", roundedRect(-Y_AXIS_LABEL_WIDTH, TITLE_VERT_OFFSET, width + LEGEND_WIDTH + Y_AXIS_LABEL_WIDTH, HEADER_WIDTH, 25, true, true, false, false))
                .style("fill", "url(#redTitleGradient)")

            widget.append("text")
                .attr("class", "widgetTitle")
                .text("Netflix Subscribers Across Regions")
                .attr("transform", "translate(" + ((width - Y_AXIS_LABEL_WIDTH + LEGEND_WIDTH) / 2) + "," + -25 + ")")

            var xAxis = g.append("g")
                .attr("class", "axis")
                .attr("id", "bottomAxis")
                .attr("transform", "translate(0," + height + ")")
                .call(lineGraphXScale.axis = d3.axisBottom(lineGraphXScale).ticks(numberOfHorzTicks))
                .style("font-size", "14px")

            xAxis.append("text")
                .attr("x", (width / 2))
                .attr("y", 50)
                .attr("text-anchor", "middle")
                .text("Date")
                .style("font-size", "17px")

            var yAxis = g.append("g")
                .attr("class", "axis")
                .attr("id", "leftAxis")
                .call(d3.axisLeft(lineGraphYScale))

            yAxis.selectAll("text")
                .style("fill", "white")
                .style("font-size", "14px")

            yAxis.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -100)
                .attr("x", -(height / 2))
                .attr("text-anchor", "middle")
                .text("Number of Netflix Subscribers")
                .style("font-size", "17px")

            d3.select('defs').append('clipPath')
                .attr('id', 'clip')
                .append('rect')
                .attr('width', width)
                .attr('height', height);

            var data = processedData;

            var localData = new Map(data);
            for ([key, value] of localData) {
                var t = value.map(el => Object.assign({}, el, { numberOfSubscribers: 0 }))
                localData.set(key, t)
            }

            var paths = g.append("g")
                .attr("clip-path", "url(#clip)")
                .attr("class", "paths");

            paths.selectAll(".line")
                .data(localData.values())
                .enter()
                .append("path")
                .attr("class", "line")
                .attr("id", (d, i) => {
                    var region = d[0].region
                    return "line" + region.replace(/[^a-zA-Z0-9]/g, ''); // Remove special characters (including spaces). Not valid for HTML ID.
                })
                .attr("fill", "none")
                .attr("stroke", d => lineColorScheme(d[0]["region"])
                )
                .attr("stroke-width", 3.5)

            var legend = g.append("g")
                .attr("class", "legend")
                .attr("transform", "translate(" + (width + LEGEND_HORZ_OFFSET) + "," + ((height / 2) - LEGEND_VERT_OFFSET) + ")");

            var legendRow = legend.selectAll(".legendRow")
                .data(data.keys())

            legendRow.enter()
                .append("g")
                .append("text")
                .attr("y", (d, i) => i * SPACE_BETWEEN_ROWS)
                .style("fill", "white")
                .style("font-size", "17px")
                .style("alignment-baseline", "central")
                .style("font-family", "Montserrat")
                .text(d => d)

            legendRow.enter()
                .append("circle")
                .attr("cx", -CIRCLE_HORZ_OFFSET)
                .attr("cy", (d, i) => i * SPACE_BETWEEN_ROWS)
                .attr("r", CIRCLE_RADIUS)
                .style("fill", d => lineColorScheme(d))

            var transition = d3.select({}).transition()
                .duration(duration)
                .ease(d3.easeLinear);

            var tickCounter = 0;
            (function tick() {
                transition = transition.each(function () {
                    var quarterIndex = 0;
                    data.forEach((val, key) => {

                        var newDataPoint = val.shift();
                        var now = newDataPoint.date;
                        var tempArr = localData.get(key);
                        for (var i = tickCounter; i < tempArr.length; i++) {
                            tempArr[i].numberOfSubscribers = newDataPoint.numberOfSubscribers;
                        }
                        localData.set(key, tempArr);

                        lineGraphXScale.domain([startingDate, newDataPoint.date]);

                        // Redraw the line
                        d3.select("#line" + key.replace(/[^a-zA-Z0-9]/g, '')) // Remove special characters (including spaces). Not valid for HTML ID.
                            .transition()
                            .duration(duration)
                            .ease(d3.easeLinear)
                            .attr('d', d3.line()
                                .curve(d3.curveBasis)
                                .x(function (d, i) {
                                    var x = lineGraphXScale(d.date);
                                    return x;
                                })
                                .y(function (d, i) {
                                    var y = lineGraphYScale(d.numberOfSubscribers);
                                    return y;
                                }))
                            .attr('transform', null);
                    })

                    d3.select(".selectedContentLine").select("line")
                        .transition().ease(d3.easeLinear).duration(duration)
                        .attr("x1", d => lineGraphXScale(new Date(d["Netflix Release Date"])))
                        .attr("x2", d => lineGraphXScale(new Date(d["Netflix Release Date"])))
                    d3.select(".selectedContentLine").select("text")
                        .transition().ease(d3.easeLinear).duration(duration)
                        .attr("x", d => lineGraphXScale(new Date(d["Netflix Release Date"])) + 10)

                    // Slide x axis to the  left
                    xAxis.transition().ease(d3.easeLinear).duration(duration).call(lineGraphXScale.axis.ticks(numberOfHorzTicks))


                    tickCounter++;

                }).transition()
                    .on('start', () => {
                        if (tickCounter < quarterLabels.length) {
                            tick()
                        }
                    })
            })();


        }
        function drawScatterPlot(content, graphTitle, width, height) {

            var g = d3.select(".boxOfficeTimeScatterPlot")
            const TITLE_VERT_OFFSET = -50;
            const X_AXIS_LABEL_HEIGHT = 90;
            const Y_AXIS_LABEL_WIDTH = 70;
            const LEGEND_WIDTH = 350;
            var widget = g.append("g").
                attr("class", "widgetBack");

            widget.append("rect")
                .attr("class", "widgetBackground")
                .attr("x", -Y_AXIS_LABEL_WIDTH)
                .attr("y", TITLE_VERT_OFFSET)
                .attr("width", width + Y_AXIS_LABEL_WIDTH + LEGEND_WIDTH)
                .attr("height", (height + HEADER_WIDTH + X_AXIS_LABEL_HEIGHT))
                .attr("rx", WIDGET_CORNER_RADIUS)
                .attr("ry", WIDGET_CORNER_RADIUS)

            widget.append("path")
                .attr("class", "widgetHeader")
                .attr("d", roundedRect(-Y_AXIS_LABEL_WIDTH, TITLE_VERT_OFFSET, width + LEGEND_WIDTH + Y_AXIS_LABEL_WIDTH, HEADER_WIDTH, 25, true, true, false, false))
                .style("fill", "url(#redTitleGradient)")

            widget.append("text")
                .attr("class", "widgetTitle")
                .text(graphTitle)
                .attr("transform", "translate(" + ((width - Y_AXIS_LABEL_WIDTH + LEGEND_WIDTH) / 2) + "," + -25 + ")")

            content = d3.filter(content, d => d["IMDb Score"] != "");
            content = d3.filter(content, d => d["Genre"] != "");

            const scoreExtents = d3.extent(content, d => +d["IMDb Score"])
            const releaseDateExtents = d3.extent(content, d => new Date(d["Netflix Release Date"]));

            var xScale = d3.scaleTime().range([0, width]).domain(releaseDateExtents);
            var yScale = d3.scaleLinear().range([0, height]).domain([scoreExtents[1], 1])

            //Get genre as array.
            var contentGenres = new Array;
            content.forEach(c => {
                contentGenres.push(c["Genre"].split(', '));
                c["Genre"] = c["Genre"].split(", ");
            })

            //Convert array of arrays to single array
            const merged = [].concat.apply([], contentGenres);
            //Get unique values from merged, and remove null genre.
            const unique = Array.from(new Set(merged))
            const genreColorScheme = d3.scaleOrdinal().domain(unique).range(d3.schemeSet1)
            const SPACE_BETWEEN_ROWS = 25;
            const SPACE_BETWEEN_COLS = 150;
            const NUMBER_OF_ELEMENTS_PER_COL = 14;
            const CIRCLE_HORZ_OFFSET = 15;
            const CIRCLE_RADIUS = 8;
            const LEGEND_HORZ_OFFSET = 70;
            const LEGEND_VERT_OFFSET = 140;
            var legend = g.append("g")
                .attr("class", "legend")
                .attr("transform", "translate(" + (width + LEGEND_HORZ_OFFSET) + "," + ((height / 2) - LEGEND_VERT_OFFSET) + ")");

            var legendRow = legend.selectAll(".legendRow")
                .data(unique)

            var lg = legendRow.enter()
                .append("g")
                .attr("class", "legendRow")
                .on("mouseover", (m, data) => {
                    legend.selectAll("circle,text") //highlight legend
                        .transition("legendHoverTrans")
                        .duration(1050)
                        .style("fill-opacity", d => {
                            return d == data ? "1" : "0.4";
                        })
                    d3.selectAll(".scatterPlotPoint")
                        .style("fill-opacity", d => {
                            return d.Genre.indexOf(data) > -1 ? "1" : "0.2";
                        })
                        .attr("fill", d => {
                            return d.Genre.indexOf(data) > -1 ? genreColorScheme(data) : netflixColor;

                        })
                        .attr("r", d => {
                            return d.Genre.indexOf(data) > -1 ? 2 : 1;
                        })

                    drawTrendLine(content.filter(d => d.Genre.indexOf(data) > -1), g, xScale, yScale);


                }).on("mouseout", (m, data) => {
                    legend.selectAll("circle,text")
                        .transition("legendExitTrans")
                        .duration(250)
                        .style("fill-opacity", 1);

                    d3.selectAll(".scatterPlotPoint")
                        .style("fill-opacity", 1)
                        .attr("fill", netflixColor)
                        .attr("r", 1);
                    drawTrendLine(content, g, xScale, yScale);

                })


            lg.append("text")
                .attr("x", (d, i) => (i >= NUMBER_OF_ELEMENTS_PER_COL) ? SPACE_BETWEEN_COLS : 0)
                .attr("y", (d, i) => (i % NUMBER_OF_ELEMENTS_PER_COL) * SPACE_BETWEEN_ROWS)
                .style("fill", "white")
                .style("font-size", "17px")
                .style("alignment-baseline", "central")
                .style("font-family", "Montserrat")
                .text(d => d)

            lg.append("circle")
                .attr("cx", (d, i) => (i >= NUMBER_OF_ELEMENTS_PER_COL) ? SPACE_BETWEEN_COLS - CIRCLE_HORZ_OFFSET : -CIRCLE_HORZ_OFFSET)
                .attr("cy", (d, i) => (i % NUMBER_OF_ELEMENTS_PER_COL) * SPACE_BETWEEN_ROWS)
                .attr("r", CIRCLE_RADIUS)
                .style("fill", d => genreColorScheme(d))

            var xAxis = g.select("g #bottomAxis")
                .raise()
                .attr("class", "axis")
                .attr("id", "bottomAxis")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale))

            xAxis.selectAll("text")
                .attr("y", 15)
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")

            xAxis.append("text")
                .attr("x", (width / 2))
                .attr("y", 50)
                .attr("text-anchor", "middle")
                .text("Date")
                .style("font-size", "17px")

            var yAxis = g.select("g #leftAxis")
                .raise()
                .attr("class", "axis")
                .attr("id", "leftAxis")
            yAxis.call(d3.axisLeft(yScale).ticks(4))
                .selectAll("text")
                .style("fill", "white")
                .style("font-size", "14px")

            yAxis.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -40)
                .attr("x", -(height / 2))
                .attr("text-anchor", "middle")
                .text("IMDb Score")
                .style("font-size", "17px")

            g.append("g")
                .attr("class", "dots")
                .selectAll("dot")
                .data(content)
                .join("circle")
                .attr("class", "scatterPlotPoint")
                .attr("cx", d => xScale(new Date(d["Netflix Release Date"])))
                .attr("cy", d => yScale(+d["IMDb Score"]))
                .attr("r", 1)
                .attr("fill", netflixColor)


            drawTrendLine(content, g, xScale, yScale);
        }

        function drawTrendLine(content, g, xScale, yScale) {
            // Best Fit Line, based on https://stackoverflow.com/questions/57559499/plotting-a-trendline-with-d3-actual-forecast
            var regression = ss.linearRegression(content.map(d => {

                var date = +(new Date(d["Netflix Release Date"]));
                var score = +d["IMDb Score"];

                return [date, score]
            }))

            var lin = ss.linearRegressionLine(regression)
            var lindata = xScale.domain().map(x => {
                return {
                    releaseDate: (x),
                    score: lin(+x)
                }
            })
            var line = d3.line()
                .x(function (d, i) {
                    return xScale(d.releaseDate);
                })
                .y(function (d) {
                    return yScale(d.score);
                })

            var trendlines = g.selectAll(".trendline")
                .data([lindata])
                .join(
                    function (enter) {
                        return enter.append("path")
                            .attr("class", "trendline")
                            .style("stroke-dasharray", ("20, 20"))
                            .attr("stroke", "white")
                            .attr("stroke-width", 2)
                            .attr("d", line)
                    },
                    function (update) {
                        return update
                            .transition()
                            .duration(1000)
                            .attr("d", line)
                    },
                    function (exit) {
                        return exit.remove();
                    }

                );
        }

        Promise.all([
            d3.csv("data/NetflixSubscribersbyCountryfrom2018toQ2_2020.csv"),
            d3.csv("data/NetflixSubscribersbyCountry.csv"),
            d3.csv("data/netflix-rotten-tomatoes-metacritic-imdb.csv"),
            //d3.csv("data/movie_metadata.csv"),
            d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson"),
        ]).then(function (files) {
            const netflixSubscribersByCountry = files[1]
            const netflixSubscribersByRegion = files[0]
            const netflixShows = files[2]
            //const movieData = files[2]
            const mapData = files[3]

            // Append SVG Object to the page
            d3.select("body")
                .append("svg")
                .attr('width', 2200)
                .attr('height', 2000)
            createDefs();
            linkCountryNaming(mapData, netflixSubscribersByCountry)
            var path = displayMap(mapData, netflixSubscribersByCountry)
            const barGraphSize = [590, 300];
            const graphPos = [935, 50];
            const boxOfficeSuccessGraphPos = [1610, 50];
            const lineGraphPos = [140, 700];
            const lineGraphSize = [680, 300];
            const scatterPlotPos = [1250, 700];
            const scatterPlotSize = [600, 300];
            const periodBetweenGraphs = 1000;


            initGraph(graphPos, "topContentBarGraph")
            initGraph(boxOfficeSuccessGraphPos, "boxOfficeSucessGraph")
            initGraph(scatterPlotPos, "boxOfficeTimeScatterPlot")
            var topContent = getTopContent(netflixShows, null, 10);

            const boxOfficeExtents = d3.extent(netflixShows, d => +d["Boxoffice"].replace(/[^\w\s]/gi, ''))
            var delay = 0;
            const delayBetweenYearDisplay = 5000;

            displaySubscribersByRegion(netflixSubscribersByRegion, lineGraphPos, lineGraphSize[0], lineGraphSize[1])

            // const year = 2019;
            // var centroids = mapCentroidsToData(netflixShows, mapData, path, year)
            // displayTopContentBubbles(centroids, netflixShows, mapData, path, year, boxOfficeExtents)
            // drawHighestRatedGraph(topContent.get(year), "Highest Rated Content On Netflix During " + year, barGraphSize[0], barGraphSize[1])
            // drawBoxOfficeSuccessGraph(topContent.get(year), "Box Office Of Top Content On Netflix During " + year, barGraphSize[0], barGraphSize[1])

            drawScatterPlot(netflixShows, "Content released on Netflix over time", scatterPlotSize[0], scatterPlotSize[1])
            centroidDataForEachYear = getCountryCentroidsWithTopContentEachYear(topContent, netflixShows, mapData, path);
            topContent.forEach((content, year) => {
                setTimeout(function () {
                    displayTopContentBubbles(centroidDataForEachYear.get(year), netflixShows, mapData, path, year, boxOfficeExtents)
                    drawHighestRatedGraph(content, "Highest Rated Content On Netflix During " + year, barGraphSize[0], barGraphSize[1])
                    drawBoxOfficeSuccessGraph(content, "Box Office Of Top Content On Netflix During " + year, barGraphSize[0], barGraphSize[1])
                }, delay);
                delay += delayBetweenYearDisplay
            })

        }).catch(function (err) {
            console.log(err)
            // handle error here
        })


    </script>
</body>

</html>