<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Lab 4 - Spotify Visualisations</title>
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,500,800" rel="stylesheet">

    <style>
        body {
            background-color: #1a1a1a;
        }

        .axis path,
        line {
            stroke: white !important;
        }

        .axis text {
            fill: white !important
        }
    </style>
</head>

<body>
    <h1>Hello</h1>
    <script src='https://d3js.org/d3.v7.js'></script>
    <script>

        const defaultMapColor = "#373737"
        const netflixColor = "#E50914"
        const netflixColorDarker = "#6e1115"

        const white = "#F5F5F1"
        const whiteDarker = "#c4c4c0"

        function subscriberArrayToMap(netflixSubscribersByCountry) {
            var map = (d3.group(netflixSubscribersByCountry, d => d.Country));
            map.forEach((element, key) => {
                map.set(key, element[0])
            })

            return map

        }

        function linkCountryNaming(mapData, netflixSubscribersByCountry) {

            mapData.features.forEach(element => {
                element.properties.name = element.properties.name.trim()
            })

            netflixSubscribersByCountry.forEach(element => {
                element.Country = element.Country.trim()
            })
            mapData.features.forEach(element => {
                switch (element.properties.name) {
                    case "USA":
                        element.properties.name = "United States"
                        break;
                    case "England":
                        element.properties.name = "United Kingdom"
                        break;
                    case "Slovakia":
                        element.properties.name = "Slovak Republic"
                        break;
                    default:
                        break;
                }
            });

            // const netflixSubMap = subscriberArrayToMap(netflixSubscribersByCountry)
            // netflixSubMap.forEach((element, key) => {

            //     const indexOfMapContainingCountry = mapData.features.map(function (e) {
            //         return e.properties.name
            //     }).indexOf(key)

            //     if (indexOfMapContainingCountry > 0) {

            //     } else {
            //         console.log("not found `" + key + "`")
            //     }


            // })
        }

        function displayMap(mapData, subscriberData) {
            const X_SIZE = 1150;
            const Y_SIZE = 750;
            const X_MARGIN = 50;
            const Y_MARGIN = 50;

            const X_MAX = X_SIZE - X_MARGIN * 2;
            const Y_MAX = Y_SIZE - Y_MARGIN * 2;

            const projection = d3.geoMercator()
                .scale(160)
                .center([0, 50])
                .translate([X_MAX / 2, Y_MAX / 2]);
            const path = d3.geoPath(projection);

            var paths = d3.select("svg")
                .append("g")
                .attr("class", "map")
                .selectAll("path")
                .data(mapData.features)
                .enter()
                .append("path")
                .attr("class", "country")
                .attr("id", (d) => d.properties.name)
                .attr("d", (d) => path(d))
                .attr("fill", defaultMapColor)
                .style("stroke", "black")
                .style("stroke-width", 0);

            const extents = getSubscriberExtentsAcrossQuarters(subscriberData);
            const delayBetweenColourShifts = 1000;
            const durationOfColourShifts = 1000;
            const quarters = subscriberData.columns.filter(column => column.includes("# of Subscribers"))


            const colourScale = d3.scaleLinear()
                .domain(extents)
                .range([defaultMapColor, netflixColor])

            paths.transition()
                .delay(delayBetweenColourShifts)
                .duration(durationOfColourShifts)
                .attr("fill", (d) => setCountryColour(d,
                    subscriberData,
                    colourScale,
                    "# of Subscribers Q1 2021"))

                //     .transition()
                // .delay(delayBetweenColourShifts)
                // .duration(durationOfColourShifts)
                // .attr("fill", "green")

                .transition()
                .delay(delayBetweenColourShifts)
                .duration(durationOfColourShifts)
                .attr("fill", (d) => {


                    const col = setCountryColour(d,
                        subscriberData,
                        colourScale,
                        "# of Subscribers Q4 2021 (Estimate)")
                    return col;

                })
            return path;
        }

        function getSubscriberExtentsAcrossQuarters(subscriberData) {

            const quarters = subscriberData.columns.filter(column => column.includes("# of Subscribers"))

            var subscriberExtents = [];
            quarters.forEach(quarter => {
                const quarterExtents = d3.extent(subscriberData, (d) => {
                    return +d[quarter]
                })

                subscriberExtents =
                    [d3.min([subscriberExtents[0], quarterExtents[0]]),
                    d3.max([subscriberExtents[1], quarterExtents[1]])]

            })
            return subscriberExtents

        }

        function setCountryColour(country, subscriberData, colourScale, field) {


            const subscriberDataForCountry = subscriberData.filter(data => {
                return country.properties.name === data.Country
            });

            if (subscriberDataForCountry.length != 0) {
                const numberOfSubscribers = +subscriberDataForCountry[0][field]

                return colourScale(numberOfSubscribers)

            } else {
                return defaultMapColor
            }
        }

        function displayTopContentBubbles(countryCentroids, content, mapData, path, year, boxOfficeExtents) {


            const maxRadius = 40;


            // Get extents (upper-lower limits) of total cases.
            // var extent = d3.extent(countryCentroids.values(), d => +d["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, ''))
            // Create radius scale.
            var radiusScale = d3.scaleLog()
                .domain([1, boxOfficeExtents[1]])
                .range([0, maxRadius])
                .clamp(true)



            var bubbles = d3.select("svg")
                .selectAll(".bubble")
                .data(countryCentroids, d => {
                    return d[0]
                })
                .join(
                    enter => {

                        var g = enter.append("g").attr("class", "bubble")
                            .on("mouseover", displayBubblePopup)
                            .on("mouseout", removeBubblePopup)
                        g.append("circle")
                            .attr("cx", d => {
                                return (d[1].centroid.x + radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))
                            })
                            .attr("cy", d => {
                                return (d[1].centroid.y + radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))
                            })
                            .attr("r", d => {
                                var boxoffice = +d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '');
                                var radius = radiusScale(boxoffice);
                                return radius
                            })
                            .attr("fill", "none")
                            .attr("stroke", "black")
                            .attr('pointer-events', 'none')

                        g.append("clipPath")
                            .attr("id", d => "bubblePath" + d[0].split(" ").join(""))
                            .append("circle")
                            .attr("cx", d => {
                                return (d[1].centroid.x + radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))
                            })
                            .attr("cy", d => {
                                return (d[1].centroid.y + radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))
                            })
                            .attr("r", d => {
                                var boxoffice = +d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '');
                                var radius = radiusScale(boxoffice);
                                return radius
                            })
                            .attr('pointer-events', 'none')

                        g.append("image")
                            .attr("x", d => {
                                return (d[1].centroid.x)
                            })
                            .attr("y", d => {
                                return d[1].centroid.y
                            })
                            .attr("clip-path", d => "url(#bubblePath" + d[0].split(" ").join("") + ")")

                            .attr("width", (maxRadius * 2))
                            .attr('xlink:href', d => d[1]["topContent"]["Image"])
                            .style("opacity", 0.7)


                    },
                    update => {
                        update.select("clipPath").select("circle")
                            .transition()
                            .duration(500)
                            .attr("r", d => radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))
                        update.select("circle")
                            .transition()
                            .duration(500)
                            .attr("r", d => radiusScale(+d[1]["topContent"]["Boxoffice"].replace(/[^\w\s]/gi, '')))

                        update
                            .select("image")
                            .attr('xlink:href', d => d[1]["topContent"]["Image"])
                    },
                    exit => {
                        return exit.remove();
                    })


        }



        function displayBubblePopup(e, d) {
            const popupWidth = 250, popupHeight = 80;
            const titleBarHeight = 20;
            const horzOffset = 100, vertOffset = -15;
            const titleOffset = 10;
            const infoOffset = 27;
            const newLineOffset = 13;

            const titleTextDelay = 50;
            const infoTextDelay = 350;
            const textDuration = 250;
            const bubbleDuration = 350;
            const mainBubbleDelay = 200;


            const bubbleCentroid = d[1].centroid;
            const movieData = d[1].topContent;
            const region = d[0];

            var g = d3.select(this)
                .raise()
                .append("g")
                .attr("class", "bubblePopup")
                .attr("transform", "translate(" + (bubbleCentroid.x + horzOffset) + "," + (bubbleCentroid.y + vertOffset) + ")")

            g.append("path")
                .attr("d", roundedRect(0, titleBarHeight, popupWidth, 0, 6, false, false, true, true))
                .transition()
                .delay(mainBubbleDelay)
                .duration(bubbleDuration)
                .attr("d", roundedRect(0, titleBarHeight, popupWidth, popupHeight, 6, false, false, true, true))
                .style("fill", "url(#whiteGradient)")

            g.append("path")
                .attr("d", roundedRect(0, 0, popupWidth, 0, 6, true, true, false, false))
                .transition()
                .duration(bubbleDuration)
                .attr("d", roundedRect(0, 0, popupWidth, titleBarHeight, 6, true, true, false, false))
                .style("fill", "url(#redGradient)")

            g.append("text")
                .attr("class", "popupTitle")
                .attr("x", (popupWidth / 2))
                .attr("y", titleOffset)
                .style("fill", "white")
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text(movieData["Title"])
                .transition()
                .duration(textDuration)
                .delay(titleTextDelay)
                .style("font-size", "12px")


            var info = g.append("g")
                .attr("class", "popupInformation")
                .attr("transform", "translate(" + (0) + "," + (infoOffset) + ")")

            info.append("text")
                .attr("x", (popupWidth / 2))
                .attr("y", 0)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text("Directed by:")
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", "10px")


            info.append("text")
                .attr("class", "boxOffice")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .style("font-weight", "bold")
                .text(movieData["Director"])
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", "10px")

            info.append("text")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset * 2)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text("Box office revenue:")
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", "10px")

            info.append("text")
                .attr("class", "boxOffice")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset * 3)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .style("font-weight", "bold")
                .text("$" + movieData["Boxoffice"])
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", "10px")

            info.append("text")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset * 4)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .text("Awards received:")
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", "10px")

            info.append("text")
                .attr("class", "boxOffice")
                .attr("x", (popupWidth / 2))
                .attr("y", newLineOffset * 5)
                .style("font-family", "Montserrat")
                .style("text-anchor", "middle")
                .style("alignment-baseline", "central")
                .style("font-size", "0px")
                .style("font-weight", "bold")
                .text(Math.trunc(+movieData["Awards Received"]))
                .transition()
                .duration(textDuration)
                .delay(infoTextDelay)
                .style("font-size", "10px")


        }

        // Taken from https://stackoverflow.com/questions/12115691/svg-d3-js-rounded-corners-on-one-side-of-a-rectangle
        function roundedRect(x, y, w, h, r, tl, tr, bl, br) {
            var retval;
            retval = "M" + (x + r) + "," + y;
            retval += "h" + (w - 2 * r);
            if (tr) { retval += "a" + r + "," + r + " 0 0 1 " + r + "," + r; }
            else { retval += "h" + r; retval += "v" + r; }
            retval += "v" + (h - 2 * r);
            if (br) { retval += "a" + r + "," + r + " 0 0 1 " + -r + "," + r; }
            else { retval += "v" + r; retval += "h" + -r; }
            retval += "h" + (2 * r - w);
            if (bl) { retval += "a" + r + "," + r + " 0 0 1 " + -r + "," + -r; }
            else { retval += "h" + -r; retval += "v" + -r; }
            retval += "v" + (2 * r - h);
            if (tl) { retval += "a" + r + "," + r + " 0 0 1 " + r + "," + -r; }
            else { retval += "v" + -r; retval += "h" + r; }
            retval += "z";
            return retval;
        }
        function removeBubblePopup(e, d) {
            d3.select(this).selectAll(".bubblePopup")
                .transition()
                .duration(150)
                .style("opacity", 0)
                .remove();

        }

        function createDefs() {
            var redGradient = d3.select("svg").append("defs")
                .append("linearGradient")
                .attr("id", "redGradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%")
                .attr("spreadMethod", "pad");
            redGradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", netflixColor)
                .attr("stop-opacity", 1);
            redGradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", netflixColorDarker)
                .attr("stop-opacity", 1);

            var whiteGradient = d3.select("defs")
                .append("linearGradient")
                .attr("id", "whiteGradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%")
                .attr("spreadMethod", "pad");
            whiteGradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", white)
                .attr("stop-opacity", 1);
            whiteGradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", whiteDarker)
                .attr("stop-opacity", 1);
            var filter = d3.select("defs")
                .append("filter")
                .attr("id", "blur")
                .append("feGaussianBlur")
                .attr("stdDeviation", 1);



        }
        function initGraph(graphPos, graphClass) {

            var g = d3.select("svg").append("g")
                .attr("class", graphClass)
                .attr("transform", "translate(" + graphPos[0] + "," + graphPos[1] + ")")

            g.append("g").attr("id", "bottomAxis")
            g.append("g").attr("id", "leftAxis")


        }

        function drawGraph(content, graphTitle, width, height) {

            var g = d3.select(".topContentBarGraph")
            g.selectAll(".title")
                .data([graphTitle])
                .join(
                    enter => {
                        return enter.append("text").attr("class", "title")
                            .text(d => d)
                            .style("fill", "white")
                            .style("font-family", "Montserrat")
                            .attr("transform", "translate(" + (width / 2) + "," + -20 + ")")
                            .style("text-anchor", "middle")
                            .style("font-size", "20px")
                    },
                    update => {
                        return update.text(d => d);
                    },
                    exit => {
                        return exit.remove();
                    })


            const titles = getTitles(content)

            const scoreExtents = d3.extent(content, d => +d["IMDb Score"])

            var xScale = d3.scaleBand().range([0, width]).domain(titles).padding(0.4);
            var yScale = d3.scaleLinear().range([0, height]).domain([scoreExtents[1], scoreExtents[0] - 0.1])

            g.select("g #bottomAxis")
                .attr("class", "axis")
                .attr("id", "bottomAxis")
                .attr("transform", "translate(0," + height + ")")
                .transition("something else")
                .duration(1000)
                .call(d3.axisBottom(xScale))
                .selectAll("text")
                .attr("x", -15)
                .attr("y", -5)
                .style("text-anchor", "end")
                .style("font-size", "14px")

            g.select("g #bottomAxis").selectAll("text")
                .style("fill", "white")
                .attr("transform", "rotate(-90)")

            g.select("g #leftAxis")
                .attr("class", "axis")
                .attr("id", "leftAxis")
                .transition()
                .duration(1000)
                .call(d3.axisLeft(yScale).ticks(5))
                .selectAll("text")
                .style("fill", "white")

            g.selectAll(".bar")
                .data(content)
                .join(
                    enter => {
                        enter.append("rect")
                            .attr("class", "bar")
                            .attr("x", d => xScale(d["Title"]))
                            .attr("y", d => height)
                            .attr("width", xScale.bandwidth())
                            .attr("height", 0)
                            .attr("fill", "url(#redGradient)")
                            .transition()
                            .duration(500)
                            .attr("height", d => height - yScale(+d["IMDb Score"]))
                            .attr("y", d => yScale(+d["IMDb Score"]))
                    },
                    update => {
                        update
                            .transition()
                            .duration(1000)
                            .attr("height", d => height - yScale(+d["IMDb Score"]))
                            .attr("y", d => yScale(+d["IMDb Score"]))

                    },
                    exit => {
                        exit.transition()
                            .remove();
                    }
                )
        }

        function drawBudgetGraph(content, graphTitle, width, height) {

            var g = d3.select(".budgetBarGraph")
            g.selectAll(".title")
                .data([graphTitle])
                .join(
                    enter => {
                        return enter.append("text").attr("class", "title")
                            .text(d => d)
                            .style("fill", "white")
                            .style("font-family", "Montserrat")
                            .attr("transform", "translate(" + (width / 2) + "," + -20 + ")")
                            .style("text-anchor", "middle")
                            .style("font-size", "20px")
                    },
                    update => {
                        return update.text(d => d);
                    },
                    exit => {
                        return exit.remove();
                    })


            const titles = getTitles(content)

            //Remove special characters from Boxoffice field.
            content.forEach(c => {
                c["Boxoffice"] = c["Boxoffice"] == "" ? null : c["Boxoffice"].replace(/[^\w\s]/gi, '')
            })
            const scoreExtents = d3.extent(content, d => +d["Boxoffice"])

            var xScale = d3.scaleBand().range([0, width]).domain(titles).padding(0.4);
            var yScale = d3.scaleLog().range([0, height]).domain([scoreExtents[1], 1])

            g.select("g #bottomAxis")
                .attr("class", "axis")
                .attr("id", "bottomAxis")
                .attr("transform", "translate(0," + height + ")")
                .transition("something else")
                .duration(1000)
                .call(d3.axisBottom(xScale))
                .selectAll("text")
                .attr("x", -15)
                .attr("y", -5)
                .style("text-anchor", "end")
                .style("font-size", "14px")

            g.select("g #bottomAxis").selectAll("text")
                .style("fill", "white")
                .attr("transform", "rotate(-90)")

            g.select("g #leftAxis")
                .attr("class", "axis")
                .attr("id", "leftAxis")
                .transition()
                .duration(1000)
                .call(d3.axisLeft(yScale).ticks(5))
                .selectAll("text")
                .style("fill", "white")

            g.selectAll(".bar")
                .data(content)
                .join(
                    enter => {
                        enter.append("rect")
                            .attr("class", "bar")
                            .attr("x", d => xScale(d["Title"]))
                            .attr("y", d => height)
                            .attr("width", xScale.bandwidth())
                            .attr("height", 0)
                            .attr("fill", "url(#redGradient)")
                            .transition()
                            .duration(500)
                            .attr("height", d => height - yScale(+d["Boxoffice"]))
                            .attr("y", d => yScale(+d["Boxoffice"]))
                    },
                    update => {
                        update
                            .transition()
                            .duration(1000)
                            .attr("height", d => height - yScale(+d["Boxoffice"]))
                            .attr("y", d => yScale(+d["Boxoffice"]))

                    },
                    exit => {
                        exit.transition()
                            .remove();
                    }
                )
        }
        function getTitles(contentArray) {

            var listOfTitles = []
            contentArray.forEach(content => {
                listOfTitles.push(content["Title"])
            })
            return listOfTitles;

        }

        function mapCentroidsToData(content, mapData, path, year) {
            console.log("Doing the big filter")

            //Create country centroids
            var countryCentroids = new Map(d3.filter((mapData.features.map(d => {
                const centroid = path.centroid(d.geometry);
                const topContentForCountry = getTopContent(content, d.properties.name, 1).get(year)[0];
                return [
                    d.properties.name, {
                        centroid: { x: centroid[0], y: centroid[1] },
                        topContent: topContentForCountry
                    }]
            })), d => d[1]["topContent"] != undefined));

            console.log("Good to go")
            return countryCentroids
        }

        function getCountryCentroidsWithTopContentEachYear(topContent, netflixShows, mapData, path) {
            var centroidDataForEachYear = new Map();
            topContent.forEach((_, year) => {
                centroidDataForEachYear.set(year, mapCentroidsToData(netflixShows, mapData, path, year))
            })
            return centroidDataForEachYear;
        }
        function getTopContent(contentData, region, number) {
            var yearExtents = d3.extent(contentData, d => new Date(d["Netflix Release Date"]).getFullYear())
            var months = ["January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"];
            var monthName = new Intl.DateTimeFormat("en-US", { month: "long" }).format;

            var topContentPerMonth = new Map();
            for (let year = yearExtents[0]; year < yearExtents[1]; year++) {

                var filtered = (region == null) ?
                    contentData
                        .filter(d => d["Boxoffice"] != "")
                        .filter(d => new Date(d["Netflix Release Date"]).getFullYear() == year)
                    : contentData
                        .filter(d => d["Boxoffice"] != "")
                        .filter(d => new Date(d["Netflix Release Date"]).getFullYear() == year)
                        .filter(d => d["Country Availability"].includes(region))

                var top10 = filtered.sort((a, b) => d3.descending(+a["IMDb Score"], +b["IMDb Score"])).slice(0, number);

                topContentPerMonth.set(year, top10);
            }
            return topContentPerMonth;

        }


        function fiscalQuarterToDate(quarter) {
            const quarterEndMonths = ["March", "June", "September", "December"];
            const month = quarterEndMonths[--quarter[1]];
            const year = quarter.substring(5, 9);

            // Sets date to 30th, while should vary between 30-31st depending on the month,
            // this doesn't add significant value.
            const date = new Date(year + " " + month + " " + 30);
            return date
        }


        function displaySubscribersByRegion(netflixSubscribersByRegion, graphPos, width, height) {

            const numberOfHorzTicks = 5;
            const duration = 1000;

            const quarterLabels = d3.filter(netflixSubscribersByRegion.columns, column => column.includes("Q"))

            var regions = new Array;

            netflixSubscribersByRegion.forEach(region => {
                regions.push(region.Area)
            })
            const lineColorScheme = d3.scaleOrdinal().domain(regions).range(d3.schemeSet1);

            //Converts data into map, where key is country, value is an array of objects containing the number of subscribers
            // across dates (set to the quarter end date)
            var processedData = new Map();
            netflixSubscribersByRegion.forEach(region => {
                var numberOfSubscribersForRegionAcrossTime = new Array;
                quarterLabels.forEach(quarter => {
                    numberOfSubscribersForRegionAcrossTime.push({
                        region: region["Area"],
                        date: fiscalQuarterToDate(quarter),
                        numberOfSubscribers: region[quarter]
                    })
                })
                processedData.set(region.Area, numberOfSubscribersForRegionAcrossTime)
            })

            var subscriberExtents = [undefined, undefined];
            quarterLabels.forEach(quarter => {
                var extentForQuarter = d3.extent(netflixSubscribersByRegion, d => +d[quarter])
                subscriberExtents[0] = d3.min([+extentForQuarter[0], +subscriberExtents[0]])
                subscriberExtents[1] = d3.max([+extentForQuarter[1], +subscriberExtents[1]])
            })

            const firstQuarterDate = fiscalQuarterToDate(quarterLabels[0]);
            const startingDate = new Date(firstQuarterDate.getFullYear(), 0, 1);
            const lastQuarterDate = fiscalQuarterToDate(quarterLabels[quarterLabels.length - 1]);
            var now = new Date(firstQuarterDate);

            var xScale = d3.scaleTime().range([0, width]).domain([startingDate, firstQuarterDate])
            var yScale = d3.scaleLinear().range([0, height]).domain([subscriberExtents[1], 0]);

            var g = d3.select("svg").append("g")
                .attr("class", "lineGraph")
                .attr("transform", "translate(" + graphPos[0] + "," + graphPos[1] + ")")

            g.append("text").attr("class", "title")
                .text("Netflix Subscribers Across Regions")
                .style("fill", "white")
                .style("font-family", "Montserrat")
                .attr("transform", "translate(" + (width / 2) + "," + -20 + ")")
                .style("text-anchor", "middle")
                .style("font-size", "20px")

            var xAxis = g.append("g")
                .attr("class", "axis")
                .attr("id", "bottomAxis")
                .attr("transform", "translate(0," + height + ")")
                .call(xScale.axis = d3.axisBottom(xScale).ticks(numberOfHorzTicks))
                .style("font-size", "14px")

            xAxis.append("text")
                .attr("x", (width / 2))
                .attr("y", 50)
                .attr("text-anchor", "middle")
                .text("Date")
                .style("font-size", "17px")

            var yAxis = g.append("g")
                .attr("class", "axis")
                .attr("id", "leftAxis")
                .call(d3.axisLeft(yScale))

            yAxis.selectAll("text")
                .style("fill", "white")
                .style("font-size", "14px")

            yAxis.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -100)
                .attr("x", -(height / 2))
                .attr("text-anchor", "middle")
                .text("Number of Netflix Subscribers")
                .style("font-size", "17px")

            d3.select('defs').append('clipPath')
                .attr('id', 'clip')
                .append('rect')
                .attr('width', width)
                .attr('height', height);

            var data = processedData;

            var localData = new Map(data);
            for ([key, value] of localData) {
                var t = value.map(el => Object.assign({}, el, { numberOfSubscribers: 0 }))
                localData.set(key, t)
            }

            var paths = g.append("g")
                .attr("clip-path", "url(#clip)")
                .attr("class", "paths");

            paths.selectAll(".line")
                .data(localData.values())
                .enter()
                .append("path")
                .attr("id", (d, i) => {
                    var region = d[0].region
                    return "line" + region.replace(/[^a-zA-Z0-9]/g, ''); // Remove special characters (including spaces). Not valid for HTML ID.
                })
                .attr("fill", "none")
                .attr("stroke", d => lineColorScheme(d[0]["region"])
                )
                .attr("stroke-width", 3.5)

            var transition = d3.select({}).transition()
                .duration(duration)
                .ease(d3.easeLinear);

            var tickCounter = 0;
            (function tick() {
                transition = transition.each(function () {
                    var quarterIndex = 0;
                    data.forEach((val, key) => {

                        var newDataPoint = val.shift();
                        var now = newDataPoint.date;
                        var tempArr = localData.get(key);
                        for (var i = tickCounter; i < tempArr.length; i++) {
                            tempArr[i].numberOfSubscribers = newDataPoint.numberOfSubscribers;
                        }
                        localData.set(key, tempArr);

                        xScale.domain([startingDate, newDataPoint.date]);

                        // Redraw the line
                        d3.select("#line" + key.replace(/[^a-zA-Z0-9]/g, '')) // Remove special characters (including spaces). Not valid for HTML ID.
                            .transition()
                            .duration(duration)
                            .attr('d', d3.line()
                                .curve(d3.curveBasis)
                                .x(function (d, i) {
                                    var x = xScale(d.date);
                                    return x;
                                })
                                .y(function (d, i) {
                                    var y = yScale(d.numberOfSubscribers);
                                    return y;
                                }))
                            .attr('transform', null);
                    })
                    // Slide x axis to the  left
                    xAxis.transition().duration(duration).call(xScale.axis.ticks(numberOfHorzTicks))

                    tickCounter++;

                }).transition()
                    .on('start', () => {
                        if (tickCounter < quarterLabels.length) {
                            tick()
                        }
                    })
            })();


        }
        Promise.all([
            d3.csv("data/NetflixSubscribersbyCountryfrom2018toQ2_2020.csv"),
            d3.csv("data/NetflixSubscribersbyCountry.csv"),
            d3.csv("data/netflix-rotten-tomatoes-metacritic-imdb.csv"),
            //d3.csv("data/movie_metadata.csv"),
            d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson"),
        ]).then(function (files) {
            const netflixSubscribersByCountry = files[1]
            const netflixSubscribersByRegion = files[0]
            const netflixShows = files[2]
            //const movieData = files[2]
            const mapData = files[3]

            // Append SVG Object to the page
            d3.select("body")
                .append("svg")
                .attr('width', 2000)
                .attr('height', 2000)
            createDefs();
            linkCountryNaming(mapData, netflixSubscribersByCountry)
            var path = displayMap(mapData, netflixSubscribersByCountry)
            const height = 500;
            const width = 500;
            const graphPos = [500, 100];
            const budgetGraphPos = [1200, 100];
            const lineGraphPos = [150, 100];

            const periodBetweenGraphs = 1000;


            initGraph(graphPos, "topContentBarGraph")
            initGraph(budgetGraphPos, "budgetBarGraph")
            var topContent = getTopContent(netflixShows, null, 10);

            const boxOfficeExtents = d3.extent(netflixShows, d => +d["Boxoffice"].replace(/[^\w\s]/gi, ''))
            var delay = 0;
            const delayBetweenYearDisplay = 5000;
            displaySubscribersByRegion(netflixSubscribersByRegion, lineGraphPos, width, height)
            // centroidDataForEachYear = getCountryCentroidsWithTopContentEachYear(topContent, netflixShows, mapData, path);

            // topContent.forEach((content, year) => {
            //     setTimeout(function () {
            //         displayTopContentBubbles(centroidDataForEachYear.get(year), netflixShows, mapData, path, year, boxOfficeExtents)
            //         drawGraph(content, "Highest rated content on Netflix during " + year, width, height)
            //         drawBudgetGraph(content, "Box Office success of top content on Netflix during " + year, width, height)
            //     }, delay);
            //     delay += delayBetweenYearDisplay
            // })

        }).catch(function (err) {
            console.log(err)
            // handle error here
        })


    </script>
</body>

</html>